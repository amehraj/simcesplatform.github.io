{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SimCES | Simulation Environment of Complex Energy System Features in short: Distribute your simulation to components Let the components communicate over Internet Run the components on any platform Create and manage simulation configurations in one file Simulate varying scenarios easily Retrieve simulation results from logging interface Optionally, run components as containers for easier development Motivation Scientific simulation systems receive benefit from a support for distribution as well as the ease of operation and management, but this combination lacks from earlier systems. Imagine a system where you can distribute the simulation task to multiple components and software platforms over a network but still manage the simulation as if you had a single piece of software. A distributed setup enables you to exploit the functionality of various platforms and combine the work of multiple simulator system developers. Besides, even real-life systems are distributed, so distribution enables you to model the world as it actually is. This increases the credibility of simulation results. The earlier distributed simulation approaches are far from easy. Functional Mock-up Interface (FMI) is widely used but assumes you run all simulation components in one computer. Ad hoc networking has been applied, but this is laborious to deploy and maintain in large systems. Finally, the analysis of simulation results is the ultimate aim of the system. There should be a means to access all of the simulation results, including the intermediate calculations of the simulation components. SimCES fulfills these requirements. It does not develop any complex algorithms for you but provides a straightforward yet powerful concept for the management of simulation systems and the communication of simulation components, including the logging of simulation results. This website This website has the following main sections: User guide Developer guide Energy-domain-specific simulation components You can find these in the menu.","title":"SimCES | Simulation Environment of Complex Energy System"},{"location":"#simces-simulation-environment-of-complex-energy-system","text":"Features in short: Distribute your simulation to components Let the components communicate over Internet Run the components on any platform Create and manage simulation configurations in one file Simulate varying scenarios easily Retrieve simulation results from logging interface Optionally, run components as containers for easier development","title":"SimCES | Simulation Environment of Complex Energy System"},{"location":"#motivation","text":"Scientific simulation systems receive benefit from a support for distribution as well as the ease of operation and management, but this combination lacks from earlier systems. Imagine a system where you can distribute the simulation task to multiple components and software platforms over a network but still manage the simulation as if you had a single piece of software. A distributed setup enables you to exploit the functionality of various platforms and combine the work of multiple simulator system developers. Besides, even real-life systems are distributed, so distribution enables you to model the world as it actually is. This increases the credibility of simulation results. The earlier distributed simulation approaches are far from easy. Functional Mock-up Interface (FMI) is widely used but assumes you run all simulation components in one computer. Ad hoc networking has been applied, but this is laborious to deploy and maintain in large systems. Finally, the analysis of simulation results is the ultimate aim of the system. There should be a means to access all of the simulation results, including the intermediate calculations of the simulation components. SimCES fulfills these requirements. It does not develop any complex algorithms for you but provides a straightforward yet powerful concept for the management of simulation systems and the communication of simulation components, including the logging of simulation results.","title":"Motivation"},{"location":"#this-website","text":"This website has the following main sections: User guide Developer guide Energy-domain-specific simulation components You can find these in the menu.","title":"This website"},{"location":"about/","text":"About SimCES and this website SimCES | Simulation Environment of Complex Energy System Copyright \u00a9 2021 Tampere University and VTT Technical Research Centre of Finland The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [ RFC2119 ] [ RFC8174 ] when, and only when, they appear in all capitals, as shown here. Contact If you have any questions or comments regarding SimCES or this website, you can contact: TODO Research projects SimCES and its parts have been developed in the following projects. ProCemPlus , \"Prosumer Centric Energy Communities \u2013 towards Energy Ecosystem\", 2019-2021, funded by Business Finland INTERRFACE , \"TSO-DSO-Consumer INTERFACE aRchitecture to provide innovative grid services for an efficient power system\", 2019-2022, funded by H2020 European Commission","title":"About..."},{"location":"about/#about-simces-and-this-website","text":"SimCES | Simulation Environment of Complex Energy System Copyright \u00a9 2021 Tampere University and VTT Technical Research Centre of Finland The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [ RFC2119 ] [ RFC8174 ] when, and only when, they appear in all capitals, as shown here.","title":"About SimCES and this website"},{"location":"about/#contact","text":"If you have any questions or comments regarding SimCES or this website, you can contact: TODO","title":"Contact"},{"location":"about/#research-projects","text":"SimCES and its parts have been developed in the following projects. ProCemPlus , \"Prosumer Centric Energy Communities \u2013 towards Energy Ecosystem\", 2019-2021, funded by Business Finland INTERRFACE , \"TSO-DSO-Consumer INTERFACE aRchitecture to provide innovative grid services for an efficient power system\", 2019-2022, funded by H2020 European Commission","title":"Research projects"},{"location":"core_abstractsimulationcomponent/","text":"AbstractSimulationComponent","title":"AbstractSimulationComponent"},{"location":"core_abstractsimulationcomponent/#abstractsimulationcomponent","text":"","title":"AbstractSimulationComponent"},{"location":"core_amqp-footprint/","text":"Footprint of AMQP items This page estimates the resource consumption of the routing-related items in RabbitMQ. Connections and channels It is recommended to only have one connection per application and keep it alive. Channels should be re-used as well: The handshake process for an AMQP connection is quite involved and requires at least 7 TCP packets (more, if TLS is used). -- -- Don't open a channel each time you are publishing. The best practice is to reuse connections and multiplex a connection between threads with channels. You should ideally only have one connection per process, and then use a channel per thread in your application. [BestPrac1] Heartbeat For RabbitMQ, the default heartbeat value is 60 seconds [Heartbeat]. Still, the value could/should be shorter: Several years worth of feedback from the users and client library maintainers suggest that values lower than 5 seconds are fairly likely to cause false positives, and values of 1 second or lower are very likely to do so. Values within the 5 to 20 seconds range are optimal for most environments. [Heartbeat] Queues Queues must always accommodate at least the messages that have not yet been retrieved from the queue. This cannot be avoided. When no longer needed, it is easy to clean up a queue with the \"auto delete\" flag that leads to the queue being removed once no client uses it anymore. Furthermore, the \"exclusive\" flag will have this effect as well. These should always be enabled, unless the use case does not work with these flags. Exclusive: \"Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.\" [AmqpRef] Auto delete: \"If set, the queue is deleted when all consumers have finished using it.\" [AmqpRef] Exchanges Exchanges do consume some additional resources: Internal database (Mnesia) tables keep an in-memory copy of all its data (even on disc nodes). Typically this will only be large when there are a large number of queues, exchanges, bindings, users or virtual hosts. [Memory] On the other hand: In Erlang, which RabbitMQ is built on, each node (broker) is a process, as is each queue. -- -- However, an exchange is not a process for scalability reasons, it is simply a row in RabbitMQ\u2019s built-in Mnesia database. [Topol] The conclusion is that exchanges are not expected to take a remarkable share of memory. Therefore, it is assumed that a \"large\" number of exchanges does not cause issues in a server. However, unused exchanges should eventually be removed. References [AmqpRef] https://www.rabbitmq.com/amqp-0-9-1-reference.html [BestPrac1] https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html [Heartbeat] https://www.rabbitmq.com/heartbeats.html [Memory] https://www.rabbitmq.com/memory-use.html [Topol] https://spring.io/blog/2011/04/01/routing-topologies-for-performance-and-scalability-with-rabbitmq/","title":"Footprint of AMQP items"},{"location":"core_amqp-footprint/#footprint-of-amqp-items","text":"This page estimates the resource consumption of the routing-related items in RabbitMQ.","title":"Footprint of AMQP items"},{"location":"core_amqp-footprint/#connections-and-channels","text":"It is recommended to only have one connection per application and keep it alive. Channels should be re-used as well: The handshake process for an AMQP connection is quite involved and requires at least 7 TCP packets (more, if TLS is used). -- -- Don't open a channel each time you are publishing. The best practice is to reuse connections and multiplex a connection between threads with channels. You should ideally only have one connection per process, and then use a channel per thread in your application. [BestPrac1]","title":"Connections and channels"},{"location":"core_amqp-footprint/#heartbeat","text":"For RabbitMQ, the default heartbeat value is 60 seconds [Heartbeat]. Still, the value could/should be shorter: Several years worth of feedback from the users and client library maintainers suggest that values lower than 5 seconds are fairly likely to cause false positives, and values of 1 second or lower are very likely to do so. Values within the 5 to 20 seconds range are optimal for most environments. [Heartbeat]","title":"Heartbeat"},{"location":"core_amqp-footprint/#queues","text":"Queues must always accommodate at least the messages that have not yet been retrieved from the queue. This cannot be avoided. When no longer needed, it is easy to clean up a queue with the \"auto delete\" flag that leads to the queue being removed once no client uses it anymore. Furthermore, the \"exclusive\" flag will have this effect as well. These should always be enabled, unless the use case does not work with these flags. Exclusive: \"Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.\" [AmqpRef] Auto delete: \"If set, the queue is deleted when all consumers have finished using it.\" [AmqpRef]","title":"Queues"},{"location":"core_amqp-footprint/#exchanges","text":"Exchanges do consume some additional resources: Internal database (Mnesia) tables keep an in-memory copy of all its data (even on disc nodes). Typically this will only be large when there are a large number of queues, exchanges, bindings, users or virtual hosts. [Memory] On the other hand: In Erlang, which RabbitMQ is built on, each node (broker) is a process, as is each queue. -- -- However, an exchange is not a process for scalability reasons, it is simply a row in RabbitMQ\u2019s built-in Mnesia database. [Topol] The conclusion is that exchanges are not expected to take a remarkable share of memory. Therefore, it is assumed that a \"large\" number of exchanges does not cause issues in a server. However, unused exchanges should eventually be removed.","title":"Exchanges"},{"location":"core_amqp-footprint/#references","text":"[AmqpRef] https://www.rabbitmq.com/amqp-0-9-1-reference.html [BestPrac1] https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html [Heartbeat] https://www.rabbitmq.com/heartbeats.html [Memory] https://www.rabbitmq.com/memory-use.html [Topol] https://spring.io/blog/2011/04/01/routing-topologies-for-performance-and-scalability-with-rabbitmq/","title":"References"},{"location":"core_block-quantity-array/","text":"Quantity array block Quantity array block is neither a topic nor message but a JSON block that can be included in any message. Use it whenever there is an array of measurement values or another quantities with an associated unit of measure. JSON structure { \"UnitOfMeasure\": \"kW\", \"Values\": [ \"0.1\", \"0.2\", \"0.3\", \"0.4\" ] } Fields and multiplicity Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Value Array of floats 1 (REQUIRED) The values. The array MUST exist, but the number of values is arbitrary.","title":"Block - Quantity array"},{"location":"core_block-quantity-array/#quantity-array-block","text":"Quantity array block is neither a topic nor message but a JSON block that can be included in any message. Use it whenever there is an array of measurement values or another quantities with an associated unit of measure.","title":"Quantity array block"},{"location":"core_block-quantity-array/#json-structure","text":"{ \"UnitOfMeasure\": \"kW\", \"Values\": [ \"0.1\", \"0.2\", \"0.3\", \"0.4\" ] }","title":"JSON structure"},{"location":"core_block-quantity-array/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Value Array of floats 1 (REQUIRED) The values. The array MUST exist, but the number of values is arbitrary.","title":"Fields and multiplicity"},{"location":"core_block-quantity/","text":"Quantity block Quantity block is neither a topic nor message but a JSON block that can be included in any message. Use the quantity block whenever there is a measurement value or another quantity with an associated unit of measure. JSON structure { \"Value\": 12.3, \"UnitOfMeasure\": \"kW\" } Fields and multiplicity Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Value Float 1 (REQUIRED) Value","title":"Block - Quantity"},{"location":"core_block-quantity/#quantity-block","text":"Quantity block is neither a topic nor message but a JSON block that can be included in any message. Use the quantity block whenever there is a measurement value or another quantity with an associated unit of measure.","title":"Quantity block"},{"location":"core_block-quantity/#json-structure","text":"{ \"Value\": 12.3, \"UnitOfMeasure\": \"kW\" }","title":"JSON structure"},{"location":"core_block-quantity/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Value Float 1 (REQUIRED) Value","title":"Fields and multiplicity"},{"location":"core_block-time-series/","text":"Time series block Time series block is neither a topic nor message but a JSON block that can be included in any message. JSON structure { \"TimeIndex\" : [ \"2020-02-17T10:00:00Z\", \"2020-02-17T11:00:00Z\", \"2020-02-17T12:00:00Z\" ], \"Series\" : { \"MagnitudeX\" : { \"UnitOfMeasure\" : \"cm\", \"Values\" : [ 1.4, 1.7, 1.6 ] }, \"MagnitudeY\" : { \"UnitOfMeasure\" : \"Cel\", \"Values\" : [ -4.2, -3.7, -3.1 ] } } } Fields and multiplicity Field Type Multiplicity Explanation TimeIndex Array of ISO 8601 date and time; UTC zone 1 (REQUIRED) The time of each value in the time series. These MUST be ordered from lowest to highest (i.e., ascending). Series Series block 1..* (REQUIRED, can be many) The actual time series Series block Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Values Array of basic type (JSON string, number or boolean); complex numbers not supported out of the box 1 (REQUIRED) Value for each time. The array length MUST be equal to the length of TimeIndex array.","title":"Block - Time series"},{"location":"core_block-time-series/#time-series-block","text":"Time series block is neither a topic nor message but a JSON block that can be included in any message.","title":"Time series block"},{"location":"core_block-time-series/#json-structure","text":"{ \"TimeIndex\" : [ \"2020-02-17T10:00:00Z\", \"2020-02-17T11:00:00Z\", \"2020-02-17T12:00:00Z\" ], \"Series\" : { \"MagnitudeX\" : { \"UnitOfMeasure\" : \"cm\", \"Values\" : [ 1.4, 1.7, 1.6 ] }, \"MagnitudeY\" : { \"UnitOfMeasure\" : \"Cel\", \"Values\" : [ -4.2, -3.7, -3.1 ] } } }","title":"JSON structure"},{"location":"core_block-time-series/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation TimeIndex Array of ISO 8601 date and time; UTC zone 1 (REQUIRED) The time of each value in the time series. These MUST be ordered from lowest to highest (i.e., ascending). Series Series block 1..* (REQUIRED, can be many) The actual time series","title":"Fields and multiplicity"},{"location":"core_block-time-series/#series-block","text":"Field Type Multiplicity Explanation UnitOfMeasure String 1 (REQUIRED) Unit of measure. This SHOULD follow the UCUM specification . Values Array of basic type (JSON string, number or boolean); complex numbers not supported out of the box 1 (REQUIRED) Value for each time. The array length MUST be equal to the length of TimeIndex array.","title":"Series block"},{"location":"core_cmp-mgmt/","text":"Platform-managed and externally managed components The simulation platform exploits virtualization to facilitate the management of components, but this has limitations. In a simulation system, it is common to include components that do not calculate anything complex but implement a simple mathematical model. Some components are even mocks that supply pre-defined information, such as values from an earlier recorded or generated timeseries. Either way, computational power is not a particular requirement. Still, because the simulation platform is distributed and expects loose coupling, even simple components should have their own runtime and a service interface. To reduce the burden of this setup, virtualization with Docker provides a solution, because it enables the declaration of an autonomous computational unit with a few lines of code. Still, this does not suit for any resource-intensive computation, especially if the intention is to use a server cluster. To gain the advantages of virtualization but still enable an arbitrary runtime and resource-intensive calculation, the simulation platform supports two types of components: Platform-managed components are executed in Docker in the same computer as the simulation platform. They are started for each simulation run and expected to stop execution when the simulation run ends. Externally managed components can be executed on any platform that can be either virtualized or not. The difference to platform managed is that the simulation platform does not control the startup and end of execution. Instead, the component must be running and connected to the message bus before any simulation can occur. The tradeoff between platform managed and externally managed is easier management versus flexibility in computational capacity.","title":"Platform-managed and externally managed components"},{"location":"core_cmp-mgmt/#platform-managed-and-externally-managed-components","text":"The simulation platform exploits virtualization to facilitate the management of components, but this has limitations. In a simulation system, it is common to include components that do not calculate anything complex but implement a simple mathematical model. Some components are even mocks that supply pre-defined information, such as values from an earlier recorded or generated timeseries. Either way, computational power is not a particular requirement. Still, because the simulation platform is distributed and expects loose coupling, even simple components should have their own runtime and a service interface. To reduce the burden of this setup, virtualization with Docker provides a solution, because it enables the declaration of an autonomous computational unit with a few lines of code. Still, this does not suit for any resource-intensive computation, especially if the intention is to use a server cluster. To gain the advantages of virtualization but still enable an arbitrary runtime and resource-intensive calculation, the simulation platform supports two types of components: Platform-managed components are executed in Docker in the same computer as the simulation platform. They are started for each simulation run and expected to stop execution when the simulation run ends. Externally managed components can be executed on any platform that can be either virtualized or not. The difference to platform managed is that the simulation platform does not control the startup and end of execution. Instead, the component must be running and connected to the message bus before any simulation can occur. The tradeoff between platform managed and externally managed is easier management versus flexibility in computational capacity.","title":"Platform-managed and externally managed components"},{"location":"core_conv-msg/","text":"Conventions of messaging Please follow these conventions if you are either: specifying a new message structure developing an application that reads or creates messages MUST: Communication protocol To communicate, the components MUST use AMQP 0-9-1 as the protocol. To implement this protocol, the components MUST use RabbitMQ. MUST: AMQP exchange type To communicate, all components MUST use the exchange type \"topic\" in the message bus. MUST: Character encoding All messages MUST be encoded in UTF-8. This is widely supported and also a common default in many environments. The existing software tools of the platform expect UTF-8. If you use another encoding, you cause a risk of conflicts. MUST: Serialization in JSON All message structures are serialized in JSON (JavaScript Object Notation). JSON is widely supported and platform-independent as well as human and machine readable. The existing software tools of the platform expect JSON. MUST: Inherit from AbstractResult When you create a result message type, you MUST inherit it from AbstractResult . This ensures that the platform can deliver and log the message as expected. Please note that this only applies to full message structures. That is, any re-usable \"blocks\" that can be included in message types, such as Time series block , do not inherit from any base message type. SHOULD: Naming When creating new items, a question arises how to formulate names. See the page Conventions of naming . SHOULD: Re-use existing structures where possible The developer SHOULD avoid creating a new structure if there is a suitable existing structure. For example, if you want to include a timeseries in a message, use the Time series block . For existing structures, see the page Message structures the related pages under it. SHOULD: Time zone When a message carries a time value, the time zone SHOULD always be UTC (Universal Coordinated Time). This prevents any conflicts due to daylight savings, which has conventionally been a difficult issue in software. Furthermore, the simulation platform may be distributed to multiple time zones. Finally, as the times are displayed to human users, it is straightforward to convert a UTC value to local time if required. SHOULD: Date, time and duration format All date and time fields SHOULD follow the standard ISO 8601. This is both human and machine readable, and modern software tools have APIs to process ISO 8601. If absolutely necessary, it is straightforward to even implement a parser, especially as there is likely no requirement to support all the features. The same applies to duration values. SHOULD: Units of measure Certain values have an associated unit of measure. As these values are serialized as a message, the unit SHOULD be explicit and follow these rules: Unit of measure (UCUM) . SHOULD: Omitting optional fields If a field in a message structure is declared OPTIONAL, any software creating a message instance SHOULD omit the field when it has no relevant value. That is, the software SHOULD NOT assign null or an empty value instead. Motivation: The semantics of an \"optional\" field truly refers to the possibility of omitting the field. However, if the value is empty instead, this can cause a question of how to interpret the value. SHOULD: Flags of AMQP queues Each AMQP queue SHOULD use the following flags: Auto delete: true Exclusive: true Auto delete means that the queue is deleted when no longer used. This enables the message bus to automatically clean up unused resources. Exclusive means that no other client can use the queue. In the context of the simulation platform, shared queues are considered needless. The exclusive flag prevents any accidental queue sharing and supposedly leads to the queue being deleted when no longer used. SHOULD: Filter messages with topics Whenever a sequence of published messages contains messages that only a subset of clients want, you SHOULD route the messages with multiple topics to avoid the need to filter messages after reception. Message routing with the message bus is efficient, because this is exactly the use case. Filtering SHOULD NOT take place in recipients, because they would have to first receive each message and then inspect the content to determine whether it is relevant or not. For example, let us imagine that there is a topic called \"PowerConsumption\" that delivers power consumption values from buildings called House A, House B and House C. There is a recipient called Monitor X that only wants to monitor House A. For this, Monitor X must receive all messages and ignore those of House B and House C. Because this is inefficient, the \"PowerConsumption\" topic SHOULD be split to \"PowerConsumption.HouseA\", \"PowerConsumption.HouseB\" and \"PowerConsumption.HouseC\". This does not prevent a recipient from receiving all messages from the subtopics of \"PowerConsumption\", because wildcard subscriptions are possible. Even if it were unclear if subtopics are needed, it is generally a good principle to separate messages. This is because the re-arrangement of topics can be expensive, whereas it is cheap to originally add more topics.","title":"Conventions of messaging"},{"location":"core_conv-msg/#conventions-of-messaging","text":"Please follow these conventions if you are either: specifying a new message structure developing an application that reads or creates messages","title":"Conventions of messaging"},{"location":"core_conv-msg/#must-communication-protocol","text":"To communicate, the components MUST use AMQP 0-9-1 as the protocol. To implement this protocol, the components MUST use RabbitMQ.","title":"MUST: Communication protocol"},{"location":"core_conv-msg/#must-amqp-exchange-type","text":"To communicate, all components MUST use the exchange type \"topic\" in the message bus.","title":"MUST: AMQP exchange type"},{"location":"core_conv-msg/#must-character-encoding","text":"All messages MUST be encoded in UTF-8. This is widely supported and also a common default in many environments. The existing software tools of the platform expect UTF-8. If you use another encoding, you cause a risk of conflicts.","title":"MUST: Character encoding"},{"location":"core_conv-msg/#must-serialization-in-json","text":"All message structures are serialized in JSON (JavaScript Object Notation). JSON is widely supported and platform-independent as well as human and machine readable. The existing software tools of the platform expect JSON.","title":"MUST: Serialization in JSON"},{"location":"core_conv-msg/#must-inherit-from-abstractresult","text":"When you create a result message type, you MUST inherit it from AbstractResult . This ensures that the platform can deliver and log the message as expected. Please note that this only applies to full message structures. That is, any re-usable \"blocks\" that can be included in message types, such as Time series block , do not inherit from any base message type.","title":"MUST: Inherit from AbstractResult"},{"location":"core_conv-msg/#should-naming","text":"When creating new items, a question arises how to formulate names. See the page Conventions of naming .","title":"SHOULD: Naming"},{"location":"core_conv-msg/#should-re-use-existing-structures-where-possible","text":"The developer SHOULD avoid creating a new structure if there is a suitable existing structure. For example, if you want to include a timeseries in a message, use the Time series block . For existing structures, see the page Message structures the related pages under it.","title":"SHOULD: Re-use existing structures where possible"},{"location":"core_conv-msg/#should-time-zone","text":"When a message carries a time value, the time zone SHOULD always be UTC (Universal Coordinated Time). This prevents any conflicts due to daylight savings, which has conventionally been a difficult issue in software. Furthermore, the simulation platform may be distributed to multiple time zones. Finally, as the times are displayed to human users, it is straightforward to convert a UTC value to local time if required.","title":"SHOULD: Time zone"},{"location":"core_conv-msg/#should-date-time-and-duration-format","text":"All date and time fields SHOULD follow the standard ISO 8601. This is both human and machine readable, and modern software tools have APIs to process ISO 8601. If absolutely necessary, it is straightforward to even implement a parser, especially as there is likely no requirement to support all the features. The same applies to duration values.","title":"SHOULD: Date, time and duration format"},{"location":"core_conv-msg/#should-units-of-measure","text":"Certain values have an associated unit of measure. As these values are serialized as a message, the unit SHOULD be explicit and follow these rules: Unit of measure (UCUM) .","title":"SHOULD: Units of measure"},{"location":"core_conv-msg/#should-omitting-optional-fields","text":"If a field in a message structure is declared OPTIONAL, any software creating a message instance SHOULD omit the field when it has no relevant value. That is, the software SHOULD NOT assign null or an empty value instead. Motivation: The semantics of an \"optional\" field truly refers to the possibility of omitting the field. However, if the value is empty instead, this can cause a question of how to interpret the value.","title":"SHOULD: Omitting optional fields"},{"location":"core_conv-msg/#should-flags-of-amqp-queues","text":"Each AMQP queue SHOULD use the following flags: Auto delete: true Exclusive: true Auto delete means that the queue is deleted when no longer used. This enables the message bus to automatically clean up unused resources. Exclusive means that no other client can use the queue. In the context of the simulation platform, shared queues are considered needless. The exclusive flag prevents any accidental queue sharing and supposedly leads to the queue being deleted when no longer used.","title":"SHOULD: Flags of AMQP queues"},{"location":"core_conv-msg/#should-filter-messages-with-topics","text":"Whenever a sequence of published messages contains messages that only a subset of clients want, you SHOULD route the messages with multiple topics to avoid the need to filter messages after reception. Message routing with the message bus is efficient, because this is exactly the use case. Filtering SHOULD NOT take place in recipients, because they would have to first receive each message and then inspect the content to determine whether it is relevant or not. For example, let us imagine that there is a topic called \"PowerConsumption\" that delivers power consumption values from buildings called House A, House B and House C. There is a recipient called Monitor X that only wants to monitor House A. For this, Monitor X must receive all messages and ignore those of House B and House C. Because this is inefficient, the \"PowerConsumption\" topic SHOULD be split to \"PowerConsumption.HouseA\", \"PowerConsumption.HouseB\" and \"PowerConsumption.HouseC\". This does not prevent a recipient from receiving all messages from the subtopics of \"PowerConsumption\", because wildcard subscriptions are possible. Even if it were unclear if subtopics are needed, it is generally a good principle to separate messages. This is because the re-arrangement of topics can be expensive, whereas it is cheap to originally add more topics.","title":"SHOULD: Filter messages with topics"},{"location":"core_conv-name/","text":"Conventions of naming It helps development if the various communication-related items have been named consistently. Then, the developers encounter fewer surprises, which often lead to bugs. The following sections specify the naming conventions of various items. Cases These are the cases referred to on this page: (a) Kebab case E.g., \"kebab-case\" All letters are in lowercase Hyphen between each word No spaces or underscores (b) Pascal case: camel case with capital first letter E.g. \"PascalCase\" Each word starts with a capital letter Other letters are in lowercase No spaces, underscores or hyphens between words See https://techterms.com/definition/pascalcase All items This includes message names, field names, etc. You SHOULD avoid the use of abbreviations For example, say \"Voltage\" rather than \"V\". Exchanges (in AMQP) Case: Kebab case If the name is hierarchical or otherwise contains logical parts, you CAN use periods ('.') as the separator. You SHOULD only use alphanumeric characters and the separators (hyphen and period, i.e., '-' and '.'). Examples: procem-management procem.whatever-id-1234 Topics (in AMQP) Case: Pascal case You SHOULD use periods to separate the levels of a hierarchy or other logical sections, because this enables wildcards to match a section. All words SHOULD be in singular. Any topic that has the purpose \"initialization\" SHOULD start with string \"Init.\". Any other topic SHOULD NOT start with \"Init.\". (For more information about initialization, see Workflow of component in simulation .) Any topic meant for the intermediate results of iteration MUST end with \".Iter\" added to the topic name that delivers the final result of iteration. Any other topic SHOULD NOT end with \".Iter\". (For more information about iteration, see Workflow of component in simulation .) Examples: ResourceState.Generator.Generator1 Init.NIS.NetworkComponentInfo MyTopic.ResourceX MyTopic.ResourceX.Iter Queues (in AMQP) You SHOULD use randomly generated names to avoid naming conflicts between software applications. When the queues are exclusive to applications, there is no reason to use an explicit name. Commonly, the APIs generate a random name if no name is supplied. Field names in message Case: Pascal case You SHOULD use singular if there is one item in the field. If the field contains an array, you SHOULD use plural. Examples: LastUpdatedInEpoch SourceProcessId Message type Case: Pascal case All words SHOULD be in singular. Examples: PriceForecastState ResourceState Enumeration values Case: Kebab case If hierarchical, you SHOULD use periods ('.') as the separator. You SHOULD only use alphanumeric characters and the separators (hyphen and period, i.e., '-' and '.'). Still, numbers SHOULD be used only if absolutely necessary. Examples: warning.convergence warning.input.range ready my-multiword-enum-value my-multiword-enum-value.sub-item","title":"Conventions of naming"},{"location":"core_conv-name/#conventions-of-naming","text":"It helps development if the various communication-related items have been named consistently. Then, the developers encounter fewer surprises, which often lead to bugs. The following sections specify the naming conventions of various items.","title":"Conventions of naming"},{"location":"core_conv-name/#cases","text":"These are the cases referred to on this page: (a) Kebab case E.g., \"kebab-case\" All letters are in lowercase Hyphen between each word No spaces or underscores (b) Pascal case: camel case with capital first letter E.g. \"PascalCase\" Each word starts with a capital letter Other letters are in lowercase No spaces, underscores or hyphens between words See https://techterms.com/definition/pascalcase","title":"Cases"},{"location":"core_conv-name/#all-items","text":"This includes message names, field names, etc. You SHOULD avoid the use of abbreviations For example, say \"Voltage\" rather than \"V\".","title":"All items"},{"location":"core_conv-name/#exchanges-in-amqp","text":"Case: Kebab case If the name is hierarchical or otherwise contains logical parts, you CAN use periods ('.') as the separator. You SHOULD only use alphanumeric characters and the separators (hyphen and period, i.e., '-' and '.'). Examples: procem-management procem.whatever-id-1234","title":"Exchanges (in AMQP)"},{"location":"core_conv-name/#topics-in-amqp","text":"Case: Pascal case You SHOULD use periods to separate the levels of a hierarchy or other logical sections, because this enables wildcards to match a section. All words SHOULD be in singular. Any topic that has the purpose \"initialization\" SHOULD start with string \"Init.\". Any other topic SHOULD NOT start with \"Init.\". (For more information about initialization, see Workflow of component in simulation .) Any topic meant for the intermediate results of iteration MUST end with \".Iter\" added to the topic name that delivers the final result of iteration. Any other topic SHOULD NOT end with \".Iter\". (For more information about iteration, see Workflow of component in simulation .) Examples: ResourceState.Generator.Generator1 Init.NIS.NetworkComponentInfo MyTopic.ResourceX MyTopic.ResourceX.Iter","title":"Topics (in AMQP)"},{"location":"core_conv-name/#queues-in-amqp","text":"You SHOULD use randomly generated names to avoid naming conflicts between software applications. When the queues are exclusive to applications, there is no reason to use an explicit name. Commonly, the APIs generate a random name if no name is supplied.","title":"Queues (in AMQP)"},{"location":"core_conv-name/#field-names-in-message","text":"Case: Pascal case You SHOULD use singular if there is one item in the field. If the field contains an array, you SHOULD use plural. Examples: LastUpdatedInEpoch SourceProcessId","title":"Field names in message"},{"location":"core_conv-name/#message-type","text":"Case: Pascal case All words SHOULD be in singular. Examples: PriceForecastState ResourceState","title":"Message type"},{"location":"core_conv-name/#enumeration-values","text":"Case: Kebab case If hierarchical, you SHOULD use periods ('.') as the separator. You SHOULD only use alphanumeric characters and the separators (hyphen and period, i.e., '-' and '.'). Still, numbers SHOULD be used only if absolutely necessary. Examples: warning.convergence warning.input.range ready my-multiword-enum-value my-multiword-enum-value.sub-item","title":"Enumeration values"},{"location":"core_create-cmp/","text":"Creating new component Ville! :)","title":"Creating new component"},{"location":"core_create-cmp/#creating-new-component","text":"Ville! :)","title":"Creating new component"},{"location":"core_exchange-mgmt/","text":"Management Exchange Management Exchange enables a communication channel that is available even when no simulation is running. To use the Exchange, the following information MUST match between all software applications. Otherwise, one or more applications will fail to use the exchange. Item Value Comment Type topic Necessary for topic-based communication Name procem-management Predefined name, so that any client can use the exchange Durable true The exchange will survive broker restart. This enables any clients to reconnect as soon as possible without a requirement to re-create the exchange. Auto delete false The exchange will remain even if no client used it, as the management exchange should always be available regardless if a simulation is running or not. Please note that this value is independent of the \"auto delete\" flag of message queues!","title":"Exchange, management"},{"location":"core_exchange-mgmt/#management-exchange","text":"Management Exchange enables a communication channel that is available even when no simulation is running. To use the Exchange, the following information MUST match between all software applications. Otherwise, one or more applications will fail to use the exchange. Item Value Comment Type topic Necessary for topic-based communication Name procem-management Predefined name, so that any client can use the exchange Durable true The exchange will survive broker restart. This enables any clients to reconnect as soon as possible without a requirement to re-create the exchange. Auto delete false The exchange will remain even if no client used it, as the management exchange should always be available regardless if a simulation is running or not. Please note that this value is independent of the \"auto delete\" flag of message queues!","title":"Management Exchange"},{"location":"core_exchange-sim/","text":"Simulation-specific exchanges Item Value Comment Type topic Necessary for topic-based communication Name procem.[unique-id-derived-from-simulation-id] The exchange name is decided by PlatformManager at simulation startup. Durable false The exchange would disappear in a broker restart. The intention is that the simulation should not continue if the broker restarts. Instead, there should be another simulation run. Auto delete true The exchange will be deleted when no longer in use (i.e., after the simulation run). This enables an automatic cleanup of unused resources. Please note that this value is independent of the \"auto delete\" flag of message queues!","title":"Exchange, simulation-specific"},{"location":"core_exchange-sim/#simulation-specific-exchanges","text":"Item Value Comment Type topic Necessary for topic-based communication Name procem.[unique-id-derived-from-simulation-id] The exchange name is decided by PlatformManager at simulation startup. Durable false The exchange would disappear in a broker restart. The intention is that the simulation should not continue if the broker restarts. Instead, there should be another simulation run. Auto delete true The exchange will be deleted when no longer in use (i.e., after the simulation run). This enables an automatic cleanup of unused resources. Please note that this value is independent of the \"auto delete\" flag of message queues!","title":"Simulation-specific exchanges"},{"location":"core_features/","text":"Features Loose coupling of components It is easier to manage a complex simulation system if the components only have the dependencies necessary for communication. The platform uses publish-subscribe communication, which decouples systems in \"time, space and synchronisation\" [1]. This means that the components do not interact directly but only via a communication platform. As the result, it is easier to develop and re-configure the setup as needed. Run simulation with single command Once the environment has been set up, it is started with a single command. The platform takes care of starting and stopping the components. Analysis of results The platform provides a logging system that captures all messages sent from a component. After the simulation, you can explore the messages either one by one or by generating time series from individual messages. Add your own components In the platform, the simulation components have a workflow they must implement. To develop your own component, the sole requirement is to implement the required communication interface and follow the workflow. Parametrize your components The platform provides a mechanism to deliver parameters to the components. You specify by yourself what the parameters are and what values these can have. For example, if your system has a storage of electricity or liquid with size as a property, you can simulate how the size affects the overall system. Geographical distribution If needed, you can distribute the simulations geographically. You can connect a simulation component from anywhere in the world via Internet. This enables a joint effort together with project partners as well as the application of a server cluster located in other premises. Principles of messaging The communication in based on a message bus. This is defined as follows: A Message Bus is a combination of a common data model, a common command set, and a messaging infrastructure to allow different systems to communicate through a shared set of interfaces. [2] As the message bus is in place, the components do not interact directly. Instead, when a component has something to say, it publishes a message. Because the bus uses the publish-subscribe paradigm, any other simulation component can subscribe for the messages to receive them. This is implemented with topics . A topic is an arbitrary string that identifies a subject of interest. The string can be, e.g., \"MyRoom.MySensorA.Temperature\" or \"WeatherInfo.CityX\". The topic-based approach realizes loose coupling, because the components do not directly connect to each other. Time and synchronization The simulator components are distributed but should still operate together, which necessitates a mechanism to synchronize time. This is implemented with epochs . An epoch represents a period of simulated time, e.g., today between 12:00 and 12:15 p.m. The length of epoch can be varied depending on the desired resolution of simulation. As epochs always represent simulated time, the duration is different in real time. This depends mainly on how fast the slowest component can simulate. Managing components in platform or externally The simulation platform exploits virtualization to facilitate the management of components, but this has limitations. Virtualization is suitable for lightweight components that do not require particularly lot of computational power. On the other hand, sometimes a more powerful platform - possibly even a server cluster - is necessary. To enable both easy management and heavy computation, the platform supports two types of components: platform managed and externally managed . Accessing the results During a simulation run, the logging system of the platform stores any messages exchanged between the simulation components. The logging system provides an HTTP API to access the messages. (In technical terms, this API is Restful, although not all HTTP-based technologies are.) Features: View the results with any HTTP client, including a web browser or a custom client View individual messages Build timeseries from multiple messages of the same structure Retrieve data in: JSON (JavaScript Object Notation) CSV (Comma-separated Values; only for timeseries) References [1] Patrick Th. Eugster, Pascal A. Felber, Rachid Guerraoui, and Anne-Marie Kermarrec. 2003. The many faces of publish/subscribe. ACM Comput. Surv. 35, 2 (June 2003), 114\u2013131. DOI:10.1145/857076.857078 [2] Gregor Hohpe and Bobby Woolf, Enterprise Integration Patterns: Message Bus. https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageBus.html","title":"Features"},{"location":"core_features/#features","text":"","title":"Features"},{"location":"core_features/#loose-coupling-of-components","text":"It is easier to manage a complex simulation system if the components only have the dependencies necessary for communication. The platform uses publish-subscribe communication, which decouples systems in \"time, space and synchronisation\" [1]. This means that the components do not interact directly but only via a communication platform. As the result, it is easier to develop and re-configure the setup as needed.","title":"Loose coupling of components"},{"location":"core_features/#run-simulation-with-single-command","text":"Once the environment has been set up, it is started with a single command. The platform takes care of starting and stopping the components.","title":"Run simulation with single command"},{"location":"core_features/#analysis-of-results","text":"The platform provides a logging system that captures all messages sent from a component. After the simulation, you can explore the messages either one by one or by generating time series from individual messages.","title":"Analysis of results"},{"location":"core_features/#add-your-own-components","text":"In the platform, the simulation components have a workflow they must implement. To develop your own component, the sole requirement is to implement the required communication interface and follow the workflow.","title":"Add your own components"},{"location":"core_features/#parametrize-your-components","text":"The platform provides a mechanism to deliver parameters to the components. You specify by yourself what the parameters are and what values these can have. For example, if your system has a storage of electricity or liquid with size as a property, you can simulate how the size affects the overall system.","title":"Parametrize your components"},{"location":"core_features/#geographical-distribution","text":"If needed, you can distribute the simulations geographically. You can connect a simulation component from anywhere in the world via Internet. This enables a joint effort together with project partners as well as the application of a server cluster located in other premises.","title":"Geographical distribution"},{"location":"core_features/#principles-of-messaging","text":"The communication in based on a message bus. This is defined as follows: A Message Bus is a combination of a common data model, a common command set, and a messaging infrastructure to allow different systems to communicate through a shared set of interfaces. [2] As the message bus is in place, the components do not interact directly. Instead, when a component has something to say, it publishes a message. Because the bus uses the publish-subscribe paradigm, any other simulation component can subscribe for the messages to receive them. This is implemented with topics . A topic is an arbitrary string that identifies a subject of interest. The string can be, e.g., \"MyRoom.MySensorA.Temperature\" or \"WeatherInfo.CityX\". The topic-based approach realizes loose coupling, because the components do not directly connect to each other.","title":"Principles of messaging"},{"location":"core_features/#time-and-synchronization","text":"The simulator components are distributed but should still operate together, which necessitates a mechanism to synchronize time. This is implemented with epochs . An epoch represents a period of simulated time, e.g., today between 12:00 and 12:15 p.m. The length of epoch can be varied depending on the desired resolution of simulation. As epochs always represent simulated time, the duration is different in real time. This depends mainly on how fast the slowest component can simulate.","title":"Time and synchronization"},{"location":"core_features/#managing-components-in-platform-or-externally","text":"The simulation platform exploits virtualization to facilitate the management of components, but this has limitations. Virtualization is suitable for lightweight components that do not require particularly lot of computational power. On the other hand, sometimes a more powerful platform - possibly even a server cluster - is necessary. To enable both easy management and heavy computation, the platform supports two types of components: platform managed and externally managed .","title":"Managing components in platform or externally"},{"location":"core_features/#accessing-the-results","text":"During a simulation run, the logging system of the platform stores any messages exchanged between the simulation components. The logging system provides an HTTP API to access the messages. (In technical terms, this API is Restful, although not all HTTP-based technologies are.) Features: View the results with any HTTP client, including a web browser or a custom client View individual messages Build timeseries from multiple messages of the same structure Retrieve data in: JSON (JavaScript Object Notation) CSV (Comma-separated Values; only for timeseries)","title":"Accessing the results"},{"location":"core_features/#references","text":"[1] Patrick Th. Eugster, Pascal A. Felber, Rachid Guerraoui, and Anne-Marie Kermarrec. 2003. The many faces of publish/subscribe. ACM Comput. Surv. 35, 2 (June 2003), 114\u2013131. DOI:10.1145/857076.857078 [2] Gregor Hohpe and Bobby Woolf, Enterprise Integration Patterns: Message Bus. https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageBus.html","title":"References"},{"location":"core_follow-run/","text":"Following a running simulation Ville! :)","title":"Follow running simulation"},{"location":"core_follow-run/#following-a-running-simulation","text":"Ville! :)","title":"Following a running simulation"},{"location":"core_install/","text":"Installation Ville! :)","title":"Installation"},{"location":"core_install/#installation","text":"Ville! :)","title":"Installation"},{"location":"core_lifecycle/","text":"Simulation lifecycle This page documents the setup of components for a simulation run. Parametrisation To execute, the components need certain parameters depending on the functionality. How these parameters are delivered depends on the way the components are managed (externally or in the platform). Types of Lifecycle Platform managed In this approach, the components is managed by the platform with Docker. This suits for components that: Do not need a server cluster Do not need \"a lot of\" computational resources In this approach, the following workflow repeats in a loop. Each round is started manually. A user starts up components manually as Docker containers In the startup, the user somehow specifies simulation parameters Among the Docker containers, there is PlatformManager that communicates the simulation parameters The parameters are sent to Management Exchange using Start (message) This enables any externally managed components to receive the parameters The components execute until finished Externally managed In this approach, the component is managed manually. Human users must make sure that the component is running before a simulation can be executed. This approach has at least the following uses: Unit testing and first experiments Components that cannot reasonably be dockerized: Uses a server cluster Requires a lot of computational resources, such as memory Possibly for components that can run concurrent simulations Each externally managed component is first started manually. Then, it runs the following workflow in a loop: Receive \"start\" message (see Start (message)) from Management Exchange; this contains simulation-run-specific parameters Set up the received parameters to the component After this, the component is ready to communicate with other components via the Simulation-specific Exchange Run the component; it will communicate with other components via the Simulation-specific Exchange The workflow is illustrated in the figure below.","title":"Simulation lifecycle"},{"location":"core_lifecycle/#simulation-lifecycle","text":"This page documents the setup of components for a simulation run.","title":"Simulation lifecycle"},{"location":"core_lifecycle/#parametrisation","text":"To execute, the components need certain parameters depending on the functionality. How these parameters are delivered depends on the way the components are managed (externally or in the platform).","title":"Parametrisation"},{"location":"core_lifecycle/#types-of-lifecycle","text":"","title":"Types of Lifecycle"},{"location":"core_lifecycle/#platform-managed","text":"In this approach, the components is managed by the platform with Docker. This suits for components that: Do not need a server cluster Do not need \"a lot of\" computational resources In this approach, the following workflow repeats in a loop. Each round is started manually. A user starts up components manually as Docker containers In the startup, the user somehow specifies simulation parameters Among the Docker containers, there is PlatformManager that communicates the simulation parameters The parameters are sent to Management Exchange using Start (message) This enables any externally managed components to receive the parameters The components execute until finished","title":"Platform managed"},{"location":"core_lifecycle/#externally-managed","text":"In this approach, the component is managed manually. Human users must make sure that the component is running before a simulation can be executed. This approach has at least the following uses: Unit testing and first experiments Components that cannot reasonably be dockerized: Uses a server cluster Requires a lot of computational resources, such as memory Possibly for components that can run concurrent simulations Each externally managed component is first started manually. Then, it runs the following workflow in a loop: Receive \"start\" message (see Start (message)) from Management Exchange; this contains simulation-run-specific parameters Set up the received parameters to the component After this, the component is ready to communicate with other components via the Simulation-specific Exchange Run the component; it will communicate with other components via the Simulation-specific Exchange The workflow is illustrated in the figure below.","title":"Externally managed"},{"location":"core_log-api/","text":"Log API Once you have run a simulation, you can access the messages published by your components from LogReader with the log API. Quick start To verify that a simulation has been executed, you can retrieve simulation information. Type this address into your web browser: http://localhost:8080/simulations This assumes that you run the simulation platform locally This will return the information of all simulation runs this far From the response, you can verify that a simulation has occurred by looking at StartTime and EndTime strings. These should have a time value that matches the time you executed the simulation. The above used a direct call to the get simulations API. Alternatively you can use the built-in user interface which can create the API calls for you. So to perform the above operation with the user interface with your browser go to address: http://localhost:8080/ Then under the \"Get metadata for all simulations\" heading press the \"send query\" button. This opens a new browser tab that uses the address from the first example and thus shows the same information. API overview LogReader implements the HTTP based API described below. LogReader also offers a simple web browser based interface for the API available from the application root path for example http://localhost:8080/. The API offers the following features: Get list of simulations there are messages for. Get information about a single simulation by its id. Get messages for a simulation. Messages can be filtered in various ways such as topic and source process. Get invalid messages published during a simulation run. Create a json or csv time series from attribute values in messages. This documentation assumes that the reader is familiar with the general messaging concepts of the simulation platform such as epochs and the various message attribute value blocks like TimeseriesBlock and QuantityBlock. The following notation is used to document request parameters and members of JSON objects in response and request bodies: name (data type, parameter type, required): description name: parameter or json member name data type: value data type such as string, integer or ISO datetime parameter type: Only for request parameters either in the URL path or in the URL query parameters required: Indicates that the parameter or JSON member is required. If this keyword is not present the parameter or member is optional. This is not used with response JSON where all members can be assumed to be present. description: Explain the purpose of the parameter or JSON member. The API is available from the application root path. So for example if LogReader is running on localhost port 8080 the URL to get all simulations would be http://localhost:8080/simulations. The examples for each API endpoint use localhost port 8080 in example request URLs. Note that the message structures and topics used in the examples may not always match the actual topics and structures defined for the platfor. The examples are based on test data included with LogReader which can be imported to the LogReader database. This allows trying out the API. See the LogReader readme for instructions how to use the test data. Get simulations method: GET path: /simulations Returns a list of simulation runs the message database has messages for. Request parameters fromDate (ISO datetime, query): Return simulation runs which have started on or after the given date. toDate (ISO datetime, query) Return simulation runs that have been started before the given date. Response List of simulation runs with the following information available about every run. SimulationId (string): The id of the simulation. Name (string): A human friendly name for the simulation. Description (string): A longer description of the simulation run meant for humans. StartTime (ISO datetime): The real world start time of the simulation run. EndTime (ISO datetime): The real world end time of the simulation run. Epochs (integer): Number of epochs in the simulation run. Processes (string[]): List of names of processes participating in the simulation run. Example Get list of simulations executed on or after 3th of June 2020 at 10:00. Request http://localhost:8080/simulations?fromDate=2020-06-03T10:00:00Z Response [ { \"Description\": \"This is a test simulation without example messages.\", \"EndTime\": \"2020-06-03T10:05:52.345000Z\", \"Epochs\": 40, \"Name\": \"test simulation 2\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\", \"battery2\" ], \"SimulationId\": \"2020-06-03T10:01:52.345Z\", \"StartTime\": \"2020-06-03T10:01:52.345000Z\" }, { \"Description\": \"This is a test simulation without example messages.\", \"EndTime\": \"2020-06-03T04:15:52.345000Z\", \"Epochs\": 100, \"Name\": \"test simulation 2\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\" ], \"SimulationId\": \"2020-06-04T04:01:52.345Z\", \"StartTime\": \"2020-06-04T04:01:52.345000Z\" } ] Get simulation method: GET path: /simulations/{simulationId} Returns general information about the given simulation run. Request parameters simulationId (string, path, required): The id of a simulation run. Response Information about the given simulation run with the same contents as in each get simulations response item. Example Get information about simulation with id 2020-06-03T04:01:52.345Z. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z Response { \"Description\": \"This is a test simulation with some example messages.\", \"EndTime\": \"2020-06-03T04:11:52.345000Z\", \"Epochs\": 50, \"Name\": \"test simulation 1\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\", \"battery2\", \"battery3\" ], \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"StartTime\": \"2020-06-03T04:01:52.345000Z\" } Get messages for simulation run method: GET path: /simulations/{simulationId}/messages Returns messages from the given simulation run. Without parameters returns all messages. Parameters allow filtering in various ways. Request parameters simulationId (string, path, required): Id of the simulation run messages are fetched from. startEpoch (integer, query): Return messages published on or after the given epoch. Not applicable if epoch, fromSimDate or toSimDate are used. endEpoch (integer, query): Return messages published on or before the given epoch. Not applicable if the epoch, fromSimDate or toSimDate are used. epoch (integer, query): return messages published during the given epoch. Not applicable if fromSimDate, toSimDate endEpoch or startEpoch are used. fromSimDate (ISO datetime, query): Return messages starting from the epoch that includes the given date. Not applicable if startEpoch, epoch or endEpoch are used. toSimDate (ISO datetime, query): Return messages published before or on the epoch that includes the given date. Not applicable if startEpoch, epoch or endEpoch are used. process (string, query): Return messages that have been published by the given processes i.e. messages whose source is the given process. Value is a comma separated list of process ids. topic (string, query): Return messages published to the given topic. Supports the same notation that is used when subscribing to the topics i.e. the same wildcard mechanism including the * and # characters. onlyWarnings: (boolean, query): If true only messages that include warnings are returned. If false messages with and without warnings are both returned. False is the default behaviour if this parameter is not used. Response List of messages as they have been saved into the database including the message metadata. The messages will be sorted in ascending order by timestamp. Example Get messages that process solarPlant1 has published to topic energy.production.solar on or before epoch 2 for simulation with id 2020-06-03T04:01:52.345Z. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/messages?process=solarPlant1&topic=energy.production.solar&endEpoch=2 Response [ { \"EpochNumber\": 1, \"MessageId\": \"solarPlant1-1\", \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.2 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": 5 }, \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"solarPlant1\", \"Timestamp\": \"2020-06-03T04:01:56Z\", \"Topic\": \"energy.production.solar\", \"Type\": \"ControlState\", \"bus\": \"bus1\" }, { \"EpochNumber\": 2, \"MessageId\": \"solarPlant1-2\", \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.5 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": 8 }, \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"solarPlant1\", \"Timestamp\": \"2020-06-03T04:02:56Z\", \"Topic\": \"energy.production.solar\", \"Type\": \"ControlState\", \"bus\": \"bus1\" } ] Get invalid messages for simulation run method: GET path: /simulations/{simulationId}/messages/invalid Returns invalid messages from the given simulation run. This is intended for debugging simulation issues. A normal simulation run should not contain invalid messages. Request parameters simulationId (string, path, required): Id of the simulation run messages are fetched from. topic (string, query): Return invalid messages published to the given topic. Supports the same notation that is used when subscribing to the topics i.e. the same wildcard mechanism including the * and # characters. Response List of invalid messages. The messages will be sorted in ascending order by timestamp. The following attributes can be available for each message: Timestamp: Timestamp from the message if the message had a valid timestamp. Otherwise this is a timestamp added when the message was stored to the database. Topic: The topic the message was published to. InvalidMessage: The message itself if it was valid json. InvalidJsonMessage: Message as a string if the message could not be parsed as json. Example Get all invalid messages for simulation with id 2020-06-03T04:01:52.345Z. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/messages/invalid Response [ { \"Timestamp\": \"2020-06-03T04:01:53Z\", \"Topic\": \"Epoch\", \"InvalidMessage\": { \"EndTime\": \"2020-06-03T14:00:00Z\", \"EpochNumber\": 1, \"MessageId\": \"SimulationManager-2\", \"SourceProcessId\": \"SimulationManager\", \"StartTime\": \"2020-06-03T13:00:00Z\", \"Timestamp\": \"2020-06-03T04:01:53Z\", \"Type\": \"Epoch\" } }, { \"Timestamp\": \"2020-06-03T04:01:54Z\", \"Topic\": \"Status.Ready\", \"InvalidJsonMessage\": \"Ready\" } ] NOTE: The first message is considered invalid since it is missing the SimulationId attribute. The second message is invalid since it is just a text string containing the word Ready. Get simple timeseries for simulation method: GET path: /simulations/{simulationId}/timeseries Returns timeseries data constructed from values of given attributes of messages that meet the given time, topic and process based filtering conditions. Request parameters Same parameters as in get simulation messages are used except onlyWarnings. In addition the following parameters are used: attrs (string, query, required) Comma separated list of names of message attributes whose values are suitable for time series and which are then included to the timeseries response. It is possible to refer deeper into the message structure using the dot notation for example foo.bar. format (string, query): Determines the response format. Possible values are csv and json. If this parameter is not used json is used as the default value. The following kinds of message attribute values are suitable for time series and can be refered to in the attrs query parameter: Plain number, string or boolean values. QuantityBlocks in which case the Value part of the QuantityBlock is added to the created time series. TimeseriesBlock if only the attribute containing a time series block is referred to all attributes in the time series are included. It is also possible to refer to a particular attribute inside the time series block to only include it to the time series to be created. Response json A JSON object with the following members: TimeIndex (timeIndex[]): List of time index objects that indicate the timestamp for the data. For example if a timeindex object is the fifth item in the timeindex list then it has the time for the fifth value in each attribute values list. If there is no value for an attribute for a corresponding timeIndex value, the value will be nul. {topic} (topicData): For each topic there is timeseries data a member named after the topic. The value is a topicDATa object. timeIndex object timestamp (ISO datetime): Indicates the simulation time for the corresponding data. epoch (integer): Indicates the epoch for the message the corresponding data is from. TopicData object {processName} (attributeValues): For each process the timeseries has values for in the given topic a member where processName is replaced with the id of the process. The value is then attributeValues object. attributeValues object {attr}: For each message attribute a member where attr is replaced with the attribute name. The value is then list of attribute values from the messages or another attributeValues object if the actual values are deeper in the message structure. csv csv data with the following column titles and colun value data types epoch (integer): Number of the epoch for the message the data in the row is from. timestamp (iso datetime): Simulation timestamp for the data in the row. {topic}:{processname}.{attr}: For each topic, process and message attribute the timeseries contains data for there is a column for it with a title consisting of the topic, process and attribute names. Attribute can consist of multiple parts separated by a period. If there is no data for the row at a certain time then the column has an empty cell. Example 1 Create a timeseries in the json format containing the real power and reactive power QuantityBlock values from messages that process solarPlant1 has published to topic energy.production.solar on or before epoch 2 for simulation with id 2020-06-03T04:01:52.345Z. The messages which are the source for this time series are shown in the response of example for Get messages for simulation. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=solarPlant1&topic=energy.production.solar&endEpoch=2&attrs=RealPower,ReactivePower Response { \"TimeIndex\": [ { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:00:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:00:00Z\" } ], \"energy.production.solar\": { \"solarPlant1\": { \"ReactivePower\": [ 0.2, 0.5 ], \"RealPower\": [ 5, 8 ] } } } Example 2 Same as example 1 except the time series should be in the csv format. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=solarPlant1&topic=energy.production.solar&endEpoch=2&attrs=RealPower,ReactivePower&format=csv Response epoch;timestamp;energy.production.solar:solarPlant1.RealPower;energy.production.solar:solarPlant1.ReactivePower 1;2020-06-03T13:00:00Z;5.0;0.2 2;2020-06-03T14:00:00Z;8.0;0.5 Example 3 Create a time series in the json format containing the chargePercentage values from the batteryState timeseries block from messages published to the energy.storage.state topic by processes battery1 and battery2 for simulation with id 2020-06-03T04:01:52.345Z. The published messages look like the following: { \"EpochNumber\": 1, \"MessageId\": \"battery1-1\", \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"battery1\", \"Timestamp\": \"2020-06-03T04:01:56Z\", \"Topic\": \"energy.storage.state\", \"Type\": \"Result\", \"batteryState\": { \"Series\": { \"capacity\": { \"UnitOfMeasure\": \"kWh\", \"Values\": [ 300, 280 ] }, \"chargePercentage\": { \"UnitOfMeasure\": \"%\", \"Values\": [ 90, 88 ] } }, \"TimeIndex\": [ \"2020-06-03T13:00:00Z\", \"2020-06-03T13:30:00Z\" ] } } Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=battery1,battery2&topic=energy.storage.state&attrs=batteryState.chargePercentage Response { \"TimeIndex\": [ { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:00:00Z\" }, { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:30:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:00:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:30:00Z\" } ], \"energy.storage.state\": { \"battery1\": { \"batteryState\": { \"chargePercentage\": [ 90, 88, 87, 91 ] } }, \"battery2\": { \"batteryState\": { \"chargePercentage\": [ 40, 42, 45, 48 ] } } } } Example 4 Same as example 3 except timeseries is created in the csv format. Request http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=battery1,battery2&topic=energy.storage.state&attrs=batteryState.chargePercentage&format=csv Response epoch;timestamp;energy.storage.state:battery1.batteryState.chargePercentage;energy.storage.state:battery2.batteryState.chargePercentage 1;2020-06-03T13:00:00Z;90;40 1;2020-06-03T13:30:00Z;88;42 2;2020-06-03T14:00:00Z;87;45 2;2020-06-03T14:30:00Z;91;48","title":"Log API"},{"location":"core_log-api/#log-api","text":"Once you have run a simulation, you can access the messages published by your components from LogReader with the log API.","title":"Log API"},{"location":"core_log-api/#quick-start","text":"To verify that a simulation has been executed, you can retrieve simulation information. Type this address into your web browser: http://localhost:8080/simulations This assumes that you run the simulation platform locally This will return the information of all simulation runs this far From the response, you can verify that a simulation has occurred by looking at StartTime and EndTime strings. These should have a time value that matches the time you executed the simulation. The above used a direct call to the get simulations API. Alternatively you can use the built-in user interface which can create the API calls for you. So to perform the above operation with the user interface with your browser go to address: http://localhost:8080/ Then under the \"Get metadata for all simulations\" heading press the \"send query\" button. This opens a new browser tab that uses the address from the first example and thus shows the same information.","title":"Quick start"},{"location":"core_log-api/#api-overview","text":"LogReader implements the HTTP based API described below. LogReader also offers a simple web browser based interface for the API available from the application root path for example http://localhost:8080/. The API offers the following features: Get list of simulations there are messages for. Get information about a single simulation by its id. Get messages for a simulation. Messages can be filtered in various ways such as topic and source process. Get invalid messages published during a simulation run. Create a json or csv time series from attribute values in messages. This documentation assumes that the reader is familiar with the general messaging concepts of the simulation platform such as epochs and the various message attribute value blocks like TimeseriesBlock and QuantityBlock. The following notation is used to document request parameters and members of JSON objects in response and request bodies: name (data type, parameter type, required): description name: parameter or json member name data type: value data type such as string, integer or ISO datetime parameter type: Only for request parameters either in the URL path or in the URL query parameters required: Indicates that the parameter or JSON member is required. If this keyword is not present the parameter or member is optional. This is not used with response JSON where all members can be assumed to be present. description: Explain the purpose of the parameter or JSON member. The API is available from the application root path. So for example if LogReader is running on localhost port 8080 the URL to get all simulations would be http://localhost:8080/simulations. The examples for each API endpoint use localhost port 8080 in example request URLs. Note that the message structures and topics used in the examples may not always match the actual topics and structures defined for the platfor. The examples are based on test data included with LogReader which can be imported to the LogReader database. This allows trying out the API. See the LogReader readme for instructions how to use the test data.","title":"API overview"},{"location":"core_log-api/#get-simulations","text":"method: GET path: /simulations Returns a list of simulation runs the message database has messages for.","title":"Get simulations"},{"location":"core_log-api/#request-parameters","text":"fromDate (ISO datetime, query): Return simulation runs which have started on or after the given date. toDate (ISO datetime, query) Return simulation runs that have been started before the given date.","title":"Request parameters"},{"location":"core_log-api/#response","text":"List of simulation runs with the following information available about every run. SimulationId (string): The id of the simulation. Name (string): A human friendly name for the simulation. Description (string): A longer description of the simulation run meant for humans. StartTime (ISO datetime): The real world start time of the simulation run. EndTime (ISO datetime): The real world end time of the simulation run. Epochs (integer): Number of epochs in the simulation run. Processes (string[]): List of names of processes participating in the simulation run.","title":"Response"},{"location":"core_log-api/#example","text":"Get list of simulations executed on or after 3th of June 2020 at 10:00.","title":"Example"},{"location":"core_log-api/#request","text":"http://localhost:8080/simulations?fromDate=2020-06-03T10:00:00Z","title":"Request"},{"location":"core_log-api/#response_1","text":"[ { \"Description\": \"This is a test simulation without example messages.\", \"EndTime\": \"2020-06-03T10:05:52.345000Z\", \"Epochs\": 40, \"Name\": \"test simulation 2\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\", \"battery2\" ], \"SimulationId\": \"2020-06-03T10:01:52.345Z\", \"StartTime\": \"2020-06-03T10:01:52.345000Z\" }, { \"Description\": \"This is a test simulation without example messages.\", \"EndTime\": \"2020-06-03T04:15:52.345000Z\", \"Epochs\": 100, \"Name\": \"test simulation 2\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\" ], \"SimulationId\": \"2020-06-04T04:01:52.345Z\", \"StartTime\": \"2020-06-04T04:01:52.345000Z\" } ]","title":"Response"},{"location":"core_log-api/#get-simulation","text":"method: GET path: /simulations/{simulationId} Returns general information about the given simulation run.","title":"Get simulation"},{"location":"core_log-api/#request-parameters_1","text":"simulationId (string, path, required): The id of a simulation run.","title":"Request parameters"},{"location":"core_log-api/#response_2","text":"Information about the given simulation run with the same contents as in each get simulations response item.","title":"Response"},{"location":"core_log-api/#example_1","text":"Get information about simulation with id 2020-06-03T04:01:52.345Z.","title":"Example"},{"location":"core_log-api/#request_1","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z","title":"Request"},{"location":"core_log-api/#response_3","text":"{ \"Description\": \"This is a test simulation with some example messages.\", \"EndTime\": \"2020-06-03T04:11:52.345000Z\", \"Epochs\": 50, \"Name\": \"test simulation 1\", \"Processes\": [ \"simulationManager\", \"weatherDivinity\", \"solarPlant1\", \"battery1\", \"battery2\", \"battery3\" ], \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"StartTime\": \"2020-06-03T04:01:52.345000Z\" }","title":"Response"},{"location":"core_log-api/#get-messages-for-simulation-run","text":"method: GET path: /simulations/{simulationId}/messages Returns messages from the given simulation run. Without parameters returns all messages. Parameters allow filtering in various ways.","title":"Get messages for simulation run"},{"location":"core_log-api/#request-parameters_2","text":"simulationId (string, path, required): Id of the simulation run messages are fetched from. startEpoch (integer, query): Return messages published on or after the given epoch. Not applicable if epoch, fromSimDate or toSimDate are used. endEpoch (integer, query): Return messages published on or before the given epoch. Not applicable if the epoch, fromSimDate or toSimDate are used. epoch (integer, query): return messages published during the given epoch. Not applicable if fromSimDate, toSimDate endEpoch or startEpoch are used. fromSimDate (ISO datetime, query): Return messages starting from the epoch that includes the given date. Not applicable if startEpoch, epoch or endEpoch are used. toSimDate (ISO datetime, query): Return messages published before or on the epoch that includes the given date. Not applicable if startEpoch, epoch or endEpoch are used. process (string, query): Return messages that have been published by the given processes i.e. messages whose source is the given process. Value is a comma separated list of process ids. topic (string, query): Return messages published to the given topic. Supports the same notation that is used when subscribing to the topics i.e. the same wildcard mechanism including the * and # characters. onlyWarnings: (boolean, query): If true only messages that include warnings are returned. If false messages with and without warnings are both returned. False is the default behaviour if this parameter is not used.","title":"Request parameters"},{"location":"core_log-api/#response_4","text":"List of messages as they have been saved into the database including the message metadata. The messages will be sorted in ascending order by timestamp.","title":"Response"},{"location":"core_log-api/#example_2","text":"Get messages that process solarPlant1 has published to topic energy.production.solar on or before epoch 2 for simulation with id 2020-06-03T04:01:52.345Z.","title":"Example"},{"location":"core_log-api/#request_2","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/messages?process=solarPlant1&topic=energy.production.solar&endEpoch=2","title":"Request"},{"location":"core_log-api/#response_5","text":"[ { \"EpochNumber\": 1, \"MessageId\": \"solarPlant1-1\", \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.2 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": 5 }, \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"solarPlant1\", \"Timestamp\": \"2020-06-03T04:01:56Z\", \"Topic\": \"energy.production.solar\", \"Type\": \"ControlState\", \"bus\": \"bus1\" }, { \"EpochNumber\": 2, \"MessageId\": \"solarPlant1-2\", \"ReactivePower\": { \"UnitOfMeasure\": \"kV.A{r}\", \"Value\": 0.5 }, \"RealPower\": { \"UnitOfMeasure\": \"kW\", \"Value\": 8 }, \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"solarPlant1\", \"Timestamp\": \"2020-06-03T04:02:56Z\", \"Topic\": \"energy.production.solar\", \"Type\": \"ControlState\", \"bus\": \"bus1\" } ]","title":"Response"},{"location":"core_log-api/#get-invalid-messages-for-simulation-run","text":"method: GET path: /simulations/{simulationId}/messages/invalid Returns invalid messages from the given simulation run. This is intended for debugging simulation issues. A normal simulation run should not contain invalid messages.","title":"Get invalid messages for simulation run"},{"location":"core_log-api/#request-parameters_3","text":"simulationId (string, path, required): Id of the simulation run messages are fetched from. topic (string, query): Return invalid messages published to the given topic. Supports the same notation that is used when subscribing to the topics i.e. the same wildcard mechanism including the * and # characters.","title":"Request parameters"},{"location":"core_log-api/#response_6","text":"List of invalid messages. The messages will be sorted in ascending order by timestamp. The following attributes can be available for each message: Timestamp: Timestamp from the message if the message had a valid timestamp. Otherwise this is a timestamp added when the message was stored to the database. Topic: The topic the message was published to. InvalidMessage: The message itself if it was valid json. InvalidJsonMessage: Message as a string if the message could not be parsed as json.","title":"Response"},{"location":"core_log-api/#example_3","text":"Get all invalid messages for simulation with id 2020-06-03T04:01:52.345Z.","title":"Example"},{"location":"core_log-api/#request_3","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/messages/invalid","title":"Request"},{"location":"core_log-api/#response_7","text":"[ { \"Timestamp\": \"2020-06-03T04:01:53Z\", \"Topic\": \"Epoch\", \"InvalidMessage\": { \"EndTime\": \"2020-06-03T14:00:00Z\", \"EpochNumber\": 1, \"MessageId\": \"SimulationManager-2\", \"SourceProcessId\": \"SimulationManager\", \"StartTime\": \"2020-06-03T13:00:00Z\", \"Timestamp\": \"2020-06-03T04:01:53Z\", \"Type\": \"Epoch\" } }, { \"Timestamp\": \"2020-06-03T04:01:54Z\", \"Topic\": \"Status.Ready\", \"InvalidJsonMessage\": \"Ready\" } ] NOTE: The first message is considered invalid since it is missing the SimulationId attribute. The second message is invalid since it is just a text string containing the word Ready.","title":"Response"},{"location":"core_log-api/#get-simple-timeseries-for-simulation","text":"method: GET path: /simulations/{simulationId}/timeseries Returns timeseries data constructed from values of given attributes of messages that meet the given time, topic and process based filtering conditions.","title":"Get simple timeseries for simulation"},{"location":"core_log-api/#request-parameters_4","text":"Same parameters as in get simulation messages are used except onlyWarnings. In addition the following parameters are used: attrs (string, query, required) Comma separated list of names of message attributes whose values are suitable for time series and which are then included to the timeseries response. It is possible to refer deeper into the message structure using the dot notation for example foo.bar. format (string, query): Determines the response format. Possible values are csv and json. If this parameter is not used json is used as the default value. The following kinds of message attribute values are suitable for time series and can be refered to in the attrs query parameter: Plain number, string or boolean values. QuantityBlocks in which case the Value part of the QuantityBlock is added to the created time series. TimeseriesBlock if only the attribute containing a time series block is referred to all attributes in the time series are included. It is also possible to refer to a particular attribute inside the time series block to only include it to the time series to be created.","title":"Request parameters"},{"location":"core_log-api/#response_8","text":"json A JSON object with the following members: TimeIndex (timeIndex[]): List of time index objects that indicate the timestamp for the data. For example if a timeindex object is the fifth item in the timeindex list then it has the time for the fifth value in each attribute values list. If there is no value for an attribute for a corresponding timeIndex value, the value will be nul. {topic} (topicData): For each topic there is timeseries data a member named after the topic. The value is a topicDATa object. timeIndex object timestamp (ISO datetime): Indicates the simulation time for the corresponding data. epoch (integer): Indicates the epoch for the message the corresponding data is from. TopicData object {processName} (attributeValues): For each process the timeseries has values for in the given topic a member where processName is replaced with the id of the process. The value is then attributeValues object. attributeValues object {attr}: For each message attribute a member where attr is replaced with the attribute name. The value is then list of attribute values from the messages or another attributeValues object if the actual values are deeper in the message structure. csv csv data with the following column titles and colun value data types epoch (integer): Number of the epoch for the message the data in the row is from. timestamp (iso datetime): Simulation timestamp for the data in the row. {topic}:{processname}.{attr}: For each topic, process and message attribute the timeseries contains data for there is a column for it with a title consisting of the topic, process and attribute names. Attribute can consist of multiple parts separated by a period. If there is no data for the row at a certain time then the column has an empty cell.","title":"Response"},{"location":"core_log-api/#example-1","text":"Create a timeseries in the json format containing the real power and reactive power QuantityBlock values from messages that process solarPlant1 has published to topic energy.production.solar on or before epoch 2 for simulation with id 2020-06-03T04:01:52.345Z. The messages which are the source for this time series are shown in the response of example for Get messages for simulation.","title":"Example 1"},{"location":"core_log-api/#request_4","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=solarPlant1&topic=energy.production.solar&endEpoch=2&attrs=RealPower,ReactivePower","title":"Request"},{"location":"core_log-api/#response_9","text":"{ \"TimeIndex\": [ { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:00:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:00:00Z\" } ], \"energy.production.solar\": { \"solarPlant1\": { \"ReactivePower\": [ 0.2, 0.5 ], \"RealPower\": [ 5, 8 ] } } }","title":"Response"},{"location":"core_log-api/#example-2","text":"Same as example 1 except the time series should be in the csv format.","title":"Example 2"},{"location":"core_log-api/#request_5","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=solarPlant1&topic=energy.production.solar&endEpoch=2&attrs=RealPower,ReactivePower&format=csv","title":"Request"},{"location":"core_log-api/#response_10","text":"epoch;timestamp;energy.production.solar:solarPlant1.RealPower;energy.production.solar:solarPlant1.ReactivePower 1;2020-06-03T13:00:00Z;5.0;0.2 2;2020-06-03T14:00:00Z;8.0;0.5","title":"Response"},{"location":"core_log-api/#example-3","text":"Create a time series in the json format containing the chargePercentage values from the batteryState timeseries block from messages published to the energy.storage.state topic by processes battery1 and battery2 for simulation with id 2020-06-03T04:01:52.345Z. The published messages look like the following: { \"EpochNumber\": 1, \"MessageId\": \"battery1-1\", \"SimulationId\": \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\": \"battery1\", \"Timestamp\": \"2020-06-03T04:01:56Z\", \"Topic\": \"energy.storage.state\", \"Type\": \"Result\", \"batteryState\": { \"Series\": { \"capacity\": { \"UnitOfMeasure\": \"kWh\", \"Values\": [ 300, 280 ] }, \"chargePercentage\": { \"UnitOfMeasure\": \"%\", \"Values\": [ 90, 88 ] } }, \"TimeIndex\": [ \"2020-06-03T13:00:00Z\", \"2020-06-03T13:30:00Z\" ] } }","title":"Example 3"},{"location":"core_log-api/#request_6","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=battery1,battery2&topic=energy.storage.state&attrs=batteryState.chargePercentage","title":"Request"},{"location":"core_log-api/#response_11","text":"{ \"TimeIndex\": [ { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:00:00Z\" }, { \"epoch\": 1, \"timestamp\": \"2020-06-03T13:30:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:00:00Z\" }, { \"epoch\": 2, \"timestamp\": \"2020-06-03T14:30:00Z\" } ], \"energy.storage.state\": { \"battery1\": { \"batteryState\": { \"chargePercentage\": [ 90, 88, 87, 91 ] } }, \"battery2\": { \"batteryState\": { \"chargePercentage\": [ 40, 42, 45, 48 ] } } } }","title":"Response"},{"location":"core_log-api/#example-4","text":"Same as example 3 except timeseries is created in the csv format.","title":"Example 4"},{"location":"core_log-api/#request_7","text":"http://localhost:8080/simulations/2020-06-03T04:01:52.345Z/timeseries?process=battery1,battery2&topic=energy.storage.state&attrs=batteryState.chargePercentage&format=csv","title":"Request"},{"location":"core_log-api/#response_12","text":"epoch;timestamp;energy.storage.state:battery1.batteryState.chargePercentage;energy.storage.state:battery2.batteryState.chargePercentage 1;2020-06-03T13:00:00Z;90;40 1;2020-06-03T13:30:00Z;88;42 2;2020-06-03T14:00:00Z;87;45 2;2020-06-03T14:30:00Z;91;48","title":"Response"},{"location":"core_logging-system/","text":"Logging system The logging system stores each message in each simulation run to enable viewing the content later. This enables the analysis of results and debugging of problems. Requirements The identified requirements include: Store messages as such (i.e., JSON) along with the necessary metadata Metadata topic timestamp simulation ID warning cause (if any) eno (epoch ID) (message) source others? Query for and view messages based on metadata Data export In JSON In CSV Data types Time series that contain time series Time series that contain single values Collect a time series from a set of JSON docs E.g., \"I want field X.Y.Z from all messages sent to topic A during simulation run B\" Should there be a feature to either include timestamps or leave them out? Presumably, the spacing of values in time series is constant anyway, and so is the submission frequency of messages from a particular process","title":"Logging system"},{"location":"core_logging-system/#logging-system","text":"The logging system stores each message in each simulation run to enable viewing the content later. This enables the analysis of results and debugging of problems.","title":"Logging system"},{"location":"core_logging-system/#requirements","text":"The identified requirements include: Store messages as such (i.e., JSON) along with the necessary metadata Metadata topic timestamp simulation ID warning cause (if any) eno (epoch ID) (message) source others? Query for and view messages based on metadata Data export In JSON In CSV Data types Time series that contain time series Time series that contain single values Collect a time series from a set of JSON docs E.g., \"I want field X.Y.Z from all messages sent to topic A during simulation run B\" Should there be a feature to either include timestamps or leave them out? Presumably, the spacing of values in time series is constant anyway, and so is the submission frequency of messages from a particular process","title":"Requirements"},{"location":"core_logwriter/","text":"LogWriter TODO! Ville","title":"LogWriter"},{"location":"core_logwriter/#logwriter","text":"TODO! Ville","title":"LogWriter"},{"location":"core_msg-abstractmessage/","text":"AbstractMessage message This page specifies the common fields of all messages. This structure is not meaningful as a standalone message, so it is analogous to an abstract base class in object-oriented programming. JSON structure \"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\", Fields and multiplicity Field Type Multiplicity Explanation Type String 1 (REQUIRED) Name of the message type. This field facilitates the processing of incoming messages and possibly debugging as well. Timestamp ISO 8601; see (1) 1 (REQUIRED) The time when the message was generated SimulationId String 1 (REQUIRED) The unique identifier of the simulation run SourceProcessId String 1 (REQUIRED) The name of the process that sent the message. This MUST be unique within the simulation run. MessageId String 1 (REQUIRED) The unique ID of the message within the simulation run. This is the name of the process + a running ID. (1): Date and time MUST be included, accuracy MUST be 1 ms, time zone MUST be UTC","title":"Message - AbstractMessage"},{"location":"core_msg-abstractmessage/#abstractmessage-message","text":"This page specifies the common fields of all messages. This structure is not meaningful as a standalone message, so it is analogous to an abstract base class in object-oriented programming.","title":"AbstractMessage message"},{"location":"core_msg-abstractmessage/#json-structure","text":"\"Type\" : \"set-message-type-here\", \"Timestamp\" : \"2020-06-03T04:04:21.045Z\", \"SimulationId\" : \"2020-06-03T04:01:52.345Z\", \"SourceProcessId\" : \"set-process-id-here\", \"MessageId\" : \"set-message-id-here\",","title":"JSON structure"},{"location":"core_msg-abstractmessage/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation Type String 1 (REQUIRED) Name of the message type. This field facilitates the processing of incoming messages and possibly debugging as well. Timestamp ISO 8601; see (1) 1 (REQUIRED) The time when the message was generated SimulationId String 1 (REQUIRED) The unique identifier of the simulation run SourceProcessId String 1 (REQUIRED) The name of the process that sent the message. This MUST be unique within the simulation run. MessageId String 1 (REQUIRED) The unique ID of the message within the simulation run. This is the name of the process + a running ID. (1): Date and time MUST be included, accuracy MUST be 1 ms, time zone MUST be UTC","title":"Fields and multiplicity"},{"location":"core_msg-abstractresult/","text":"AbstractResult message This page specifies the common base of all messages that represent a value calculated, measured or generated in a process. This structure is not meaningful as a standalone message, so it is analogous to an abstract base class in object-oriented programming. JSON structure (Fields of AbstractMessage must appear too!) \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ], Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractMessage ) Fields from the \"abstract base class\" EpochNumber UInt 1 (REQUIRED) Indicates the running ID of the epoch IterationStatus String 0..1; see (1) Indicates the status of iteration, either \"intermediate\" or \"final\" LastUpdatedInEpoch UInt 0..1 (OPTIONAL) Indicates the epoch number when this information was last updated; see (2) TriggeringMessageIds Array of strings 1..* (at least one REQUIRED) The ID of messages that were involved in triggering the calculation of this result Warnings Array of strings * (OPTIONAL) Indicates any warnings that occurred while resolving the Result; see (4) (1): This field is REQUIRED if the component participates in iteration. Otherwise, this field SHOULD be omitted. (2): If this field is not present, the recipient SHOULD consider that the information was updated in the current epoch. (3) This MUST include the triggering message that was received last This SHOULD include Epoch message if it is among triggering messages As long as the obligatory messages are there, the designer of each process can consider which additional messages to include. This field can be irrelevant in the Epoch message. (Alternatively, Epoch could include the Result received last.) (4): See the explanation of causes below. The process SHOULD omit the entire array if no warnings are relevant. Warning causes Each warning MUST specify a cause. The cause MUST either belong to base causes or be a user-defined cause. Base causes The following specifies the base causes. Each base cause has two parts, (1) \"warning\" followed by period as the separator and (2) a descriptive set of words separated with hyphens. warning.convergence The calculation failed to converge, or the control has not completely finished. The outcome is either is a default value or calculated with some secondary logic. warning.input Input is somehow invalid. warning.input-range One or more inputs are out of range. warning.input-unreliable Input is unreliable, because the data source (e.g., another process) has indicated a warning. warning.internal There is something wrong with the internal functionality of the process. warning.other Other reason; the processes SHOULD NOT use this in the output. Open issues Should there be more information about the warnings, e.g., a more elaborate description for humans to read?","title":"Message - AbstractResult"},{"location":"core_msg-abstractresult/#abstractresult-message","text":"This page specifies the common base of all messages that represent a value calculated, measured or generated in a process. This structure is not meaningful as a standalone message, so it is analogous to an abstract base class in object-oriented programming.","title":"AbstractResult message"},{"location":"core_msg-abstractresult/#json-structure","text":"(Fields of AbstractMessage must appear too!) \"EpochNumber\" : 14, \"IterationStatus\" : \"final\", // leave out when not iterating \"LastUpdatedInEpoch\" : 14, // OPTIONAL field \"TriggeringMessageIds\" : // TriggeringMessageIds are irrelevant in Epoch messages? [ \"epoch-14\", \"someprocess-14\", \"anotherprocess-14\" ], \"Warnings\" : // If warnings precede an error, it can be beneficial to provide them as well in the Error message [ \"warning.convergence\" ],","title":"JSON structure"},{"location":"core_msg-abstractresult/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractMessage ) Fields from the \"abstract base class\" EpochNumber UInt 1 (REQUIRED) Indicates the running ID of the epoch IterationStatus String 0..1; see (1) Indicates the status of iteration, either \"intermediate\" or \"final\" LastUpdatedInEpoch UInt 0..1 (OPTIONAL) Indicates the epoch number when this information was last updated; see (2) TriggeringMessageIds Array of strings 1..* (at least one REQUIRED) The ID of messages that were involved in triggering the calculation of this result Warnings Array of strings * (OPTIONAL) Indicates any warnings that occurred while resolving the Result; see (4) (1): This field is REQUIRED if the component participates in iteration. Otherwise, this field SHOULD be omitted. (2): If this field is not present, the recipient SHOULD consider that the information was updated in the current epoch. (3) This MUST include the triggering message that was received last This SHOULD include Epoch message if it is among triggering messages As long as the obligatory messages are there, the designer of each process can consider which additional messages to include. This field can be irrelevant in the Epoch message. (Alternatively, Epoch could include the Result received last.) (4): See the explanation of causes below. The process SHOULD omit the entire array if no warnings are relevant.","title":"Fields and multiplicity"},{"location":"core_msg-abstractresult/#warning-causes","text":"Each warning MUST specify a cause. The cause MUST either belong to base causes or be a user-defined cause.","title":"Warning causes"},{"location":"core_msg-abstractresult/#base-causes","text":"The following specifies the base causes. Each base cause has two parts, (1) \"warning\" followed by period as the separator and (2) a descriptive set of words separated with hyphens.","title":"Base causes"},{"location":"core_msg-abstractresult/#warningconvergence","text":"The calculation failed to converge, or the control has not completely finished. The outcome is either is a default value or calculated with some secondary logic.","title":"warning.convergence"},{"location":"core_msg-abstractresult/#warninginput","text":"Input is somehow invalid.","title":"warning.input"},{"location":"core_msg-abstractresult/#warninginput-range","text":"One or more inputs are out of range.","title":"warning.input-range"},{"location":"core_msg-abstractresult/#warninginput-unreliable","text":"Input is unreliable, because the data source (e.g., another process) has indicated a warning.","title":"warning.input-unreliable"},{"location":"core_msg-abstractresult/#warninginternal","text":"There is something wrong with the internal functionality of the process.","title":"warning.internal"},{"location":"core_msg-abstractresult/#warningother","text":"Other reason; the processes SHOULD NOT use this in the output.","title":"warning.other"},{"location":"core_msg-abstractresult/#open-issues","text":"Should there be more information about the warnings, e.g., a more elaborate description for humans to read?","title":"Open issues"},{"location":"core_msg-epoch/","text":"Epoch message This page specifies the \"Epoch\" message. JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"StartTime\" : \"2020-06-03T13:00:00Z\", \"EndTime\" : \"2020-06-03T14:00:00Z\" } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" StartTime ISO 8601 (Date and time, UTC zone) 1 (REQUIRED) Simulated start time of the epoch EndTime ISO 8601 (Date and time, UTC zone) 1 (REQUIRED) Simulated end time of the epoch","title":"Message - Epoch"},{"location":"core_msg-epoch/#epoch-message","text":"This page specifies the \"Epoch\" message.","title":"Epoch message"},{"location":"core_msg-epoch/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"StartTime\" : \"2020-06-03T13:00:00Z\", \"EndTime\" : \"2020-06-03T14:00:00Z\" }","title":"JSON structure"},{"location":"core_msg-epoch/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" StartTime ISO 8601 (Date and time, UTC zone) 1 (REQUIRED) Simulated start time of the epoch EndTime ISO 8601 (Date and time, UTC zone) 1 (REQUIRED) Simulated end time of the epoch","title":"Fields and multiplicity"},{"location":"core_msg-simstate/","text":"SimState message This message notifies about starting and ending a simulation run. JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"SimulationState\" : \"running\", \"Name\" : \"Name of the simulation\", \"Description\" : \"Longer description about the simulation\" } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractMessage ) Fields from the \"abstract base class\" SimulationState String 1 (REQUIRED) Simulation state, either \"running\" or \"stopped\" Name String 0..1 (OPTIONAL) A human-friendly name for the simulation Description String 0..1 (OPTIONAL) A longer description of the simulation run meant for humans","title":"Message - SimState"},{"location":"core_msg-simstate/#simstate-message","text":"This message notifies about starting and ending a simulation run.","title":"SimState message"},{"location":"core_msg-simstate/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"SimulationState\" : \"running\", \"Name\" : \"Name of the simulation\", \"Description\" : \"Longer description about the simulation\" }","title":"JSON structure"},{"location":"core_msg-simstate/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractMessage ) Fields from the \"abstract base class\" SimulationState String 1 (REQUIRED) Simulation state, either \"running\" or \"stopped\" Name String 0..1 (OPTIONAL) A human-friendly name for the simulation Description String 0..1 (OPTIONAL) A longer description of the simulation run meant for humans","title":"Fields and multiplicity"},{"location":"core_msg-start/","text":"Start message This message notifies components about the startup of a simulation run, delivering simulation-run-specific parameters. JSON structure { \"Type\" : \"Start\", \"Timestamp\" : \"2020-08-31T04:04:21.045Z\", \"SimulationId\" : \"set-simulation-id-here\", \"SimulationSpecificExchange\" : \"set-exchange-name-here\", \"SimulationName\" : \"set-name-here\", \"SimulationDescription\" : \"set-description-here\", \"ProcessParameters\" : { \"SimulationManager\": // There is only one Simulation Manager for each simulation run { \"ManagerName\": \"Manager\", \"InitialStartTime\": \"2020-06-28T00:00:00.000Z\", \"EpochLength\": 3600, \"MaxEpochCount\": 24, \"Components\": [ \"Load1\", \"Load2\", \"Generator\", \"GridA\" ], \"EpochTimerInterval\": 120.0, // optional \"MaxEpochResendCount\": 5 // optional }, \"LogWriter\": // There is only one Log Writer for each simulation run { \"MessageBufferMaxDocumentCount\": 10, // optional, default is 20 \"MessageBufferMaxInterval\": 5.0 // optional, default is 10.0 }, \"Dummy\": // Include this if relevant { \"DummyA\": // The identifier for the dummy component { \"MinSleepTime\": 1.0, // optional, default is 2.0 \"MaxSleepTime\": 2.5, // optional, default is 15.0 \"WarningChance\": 0.0, // optional, default is 0.0 \"SendMissChance\": 0.0, // optional, default is 0.0 \"ReceiveMissChance\": 0.0, // optional, default is 0.0 \"ErrorChance\": 0.0, // optional, default is 0.0 } }, \"StaticTimeSeriesResource\": // Example parameters for a component { \"LoadA\": // The identifier for the resource { \"ResourceType\": \"Load\", \"ResourceStateFile\": \"load.csv\" }, \"GeneratorA\": { \"ResourceType\": \"Generator\", \"ResourceStateFile\": \"generator.csv\" } } } } Fields and multiplicity Field Type Multiplicity Explanation Type String 1 (REQUIRED) The name of the message type. For Start message this MUST be equal to \"Start\". Timestamp ISO 8601; see (1) 1 (REQUIRED) The time when the message was generated SimulationId String 1 (REQUIRED) The unique identifier of the simulation run, first published in this message (i.e., specified by the sender). SimulationSpecificExchange String 1 (REQUIRED) The name of the simulation-specific Exchange that will be the channel to communicate simulation-run-specific messages SimulationName String 0..1 (OPTIONAL) A human-readable name to help in identifying the simulation run SimulationDescription String 0..1 (OPTIONAL) A human-readable description to help in identifying the simulation run ProcessParameters Object that contains other objects 0..1 (OPTIONAL) Specifies any process-specific parameters; see (2) (1) Date and time included Accuracy 1 ms UTC zone (2): REQUIRED if there are any process-specific parameters to deliver. For each object, the name is a string that matches to the identifier of the process referred to. The value is a structure defined in \"process parameter blocks\" section. Process parameter blocks This section explains the process parameter blocks used by platform core. This excludes any domain-specific blocks. Note: the Platform Manager passes these parameters directly to the Simulation Manager instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System. Simulation Manager block Field Type Multiplicity Explanation ManagerName String 1 (REQUIRED) The identifier, i.e. the SourceProcessId, for the Simulation Manager instance. InitialStartTime ISO 8601; see (a) 1 (REQUIRED) The start time for the first epoch as ISO 8601 formatted datetime string. EpochLength Integer (> 0) 1 (REQUIRED) The epoch length in seconds. MaxEpochCount Integer (> 0) 1 (REQUIRED) The maximum number of epochs in the simulation run. Components Array of strings 1..* (at least one REQUIRED) An array of the names of the components participating in the simulation. The names MUST correspond to the identifiers (i.e. the SourceProcessId) used by the components. EpochTimerInterval Float 0..1 (OPTIONAL) The time interval in seconds until Simulation Manager resends an Epoch message if some component has not responded with Status message. The default value is 120 seconds. MaxEpochResendCount Integer 0..1 (OPTIONAL) The maximum number of Epoch message resends Simulation Manager can try. The default value is 5 resends. (a) Date and time included Accuracy 1 ms Time zone information MUST be included Log Writer block Field Type Multiplicity Explanation MessageBufferMaxDocumentCount Integer (> 0) 1 (OPTIONAL) The maximum number of messages the buffer in Log Writer can hold before the messages are written to the database and the buffer is cleared. The default value is 20. MessageBufferMaxInterval Float 1 (OPTIONAL) The maximum time interval in seconds before the message buffer in Log Writer is cleared and the messages written to the database. The default value is 10 seconds. Dummy Component block Field Type Multiplicity Explanation MinSleepTime Float 1 (OPTIONAL) The minimum time in seconds the Dummy component waits after receiving an Epoch message before sending the Status message. The default value is 2 seconds. MaxSleepTime Float 1 (OPTIONAL) The maximum time in seconds the Dummy component waits after receiving an Epoch message before sending the Status message. The default value is 15 seconds. WarningChance Float 1 (OPTIONAL) The probability that a warning is included in the Status message sent to the Simulation Manager. 1 means that a warning is always included and 0 means that a warning is never included. The default value is 0. SendMissChance Float 1 (OPTIONAL) The probability that the Dummy component does not send the Status message after processing the epoch to the simulation manager. 1 means that the Status messages are never sent and 0 means that they are always sent. The default value is 0. ReceiveMissChance Float 1 (OPTIONAL) The probability that the Dummy component ignores a received Epoch message. 1 means that the Epoch messages are always ignored and 0 means that they are never ignored. The default value is 0. ErrorChance Float 1 (OPTIONAL) The probability that the Dummy component sends an error message after a received Epoch message. 1 means that an error message is always sent and 0 means that an error message is never included. The default value is 0.","title":"Message - Start"},{"location":"core_msg-start/#start-message","text":"This message notifies components about the startup of a simulation run, delivering simulation-run-specific parameters.","title":"Start message"},{"location":"core_msg-start/#json-structure","text":"{ \"Type\" : \"Start\", \"Timestamp\" : \"2020-08-31T04:04:21.045Z\", \"SimulationId\" : \"set-simulation-id-here\", \"SimulationSpecificExchange\" : \"set-exchange-name-here\", \"SimulationName\" : \"set-name-here\", \"SimulationDescription\" : \"set-description-here\", \"ProcessParameters\" : { \"SimulationManager\": // There is only one Simulation Manager for each simulation run { \"ManagerName\": \"Manager\", \"InitialStartTime\": \"2020-06-28T00:00:00.000Z\", \"EpochLength\": 3600, \"MaxEpochCount\": 24, \"Components\": [ \"Load1\", \"Load2\", \"Generator\", \"GridA\" ], \"EpochTimerInterval\": 120.0, // optional \"MaxEpochResendCount\": 5 // optional }, \"LogWriter\": // There is only one Log Writer for each simulation run { \"MessageBufferMaxDocumentCount\": 10, // optional, default is 20 \"MessageBufferMaxInterval\": 5.0 // optional, default is 10.0 }, \"Dummy\": // Include this if relevant { \"DummyA\": // The identifier for the dummy component { \"MinSleepTime\": 1.0, // optional, default is 2.0 \"MaxSleepTime\": 2.5, // optional, default is 15.0 \"WarningChance\": 0.0, // optional, default is 0.0 \"SendMissChance\": 0.0, // optional, default is 0.0 \"ReceiveMissChance\": 0.0, // optional, default is 0.0 \"ErrorChance\": 0.0, // optional, default is 0.0 } }, \"StaticTimeSeriesResource\": // Example parameters for a component { \"LoadA\": // The identifier for the resource { \"ResourceType\": \"Load\", \"ResourceStateFile\": \"load.csv\" }, \"GeneratorA\": { \"ResourceType\": \"Generator\", \"ResourceStateFile\": \"generator.csv\" } } } }","title":"JSON structure"},{"location":"core_msg-start/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation Type String 1 (REQUIRED) The name of the message type. For Start message this MUST be equal to \"Start\". Timestamp ISO 8601; see (1) 1 (REQUIRED) The time when the message was generated SimulationId String 1 (REQUIRED) The unique identifier of the simulation run, first published in this message (i.e., specified by the sender). SimulationSpecificExchange String 1 (REQUIRED) The name of the simulation-specific Exchange that will be the channel to communicate simulation-run-specific messages SimulationName String 0..1 (OPTIONAL) A human-readable name to help in identifying the simulation run SimulationDescription String 0..1 (OPTIONAL) A human-readable description to help in identifying the simulation run ProcessParameters Object that contains other objects 0..1 (OPTIONAL) Specifies any process-specific parameters; see (2) (1) Date and time included Accuracy 1 ms UTC zone (2): REQUIRED if there are any process-specific parameters to deliver. For each object, the name is a string that matches to the identifier of the process referred to. The value is a structure defined in \"process parameter blocks\" section.","title":"Fields and multiplicity"},{"location":"core_msg-start/#process-parameter-blocks","text":"This section explains the process parameter blocks used by platform core. This excludes any domain-specific blocks. Note: the Platform Manager passes these parameters directly to the Simulation Manager instance through environmental variables. They are included as part of the Start message to make the used parameters visible to the other components as well as to the Logging System.","title":"Process parameter blocks"},{"location":"core_msg-start/#simulation-manager-block","text":"Field Type Multiplicity Explanation ManagerName String 1 (REQUIRED) The identifier, i.e. the SourceProcessId, for the Simulation Manager instance. InitialStartTime ISO 8601; see (a) 1 (REQUIRED) The start time for the first epoch as ISO 8601 formatted datetime string. EpochLength Integer (> 0) 1 (REQUIRED) The epoch length in seconds. MaxEpochCount Integer (> 0) 1 (REQUIRED) The maximum number of epochs in the simulation run. Components Array of strings 1..* (at least one REQUIRED) An array of the names of the components participating in the simulation. The names MUST correspond to the identifiers (i.e. the SourceProcessId) used by the components. EpochTimerInterval Float 0..1 (OPTIONAL) The time interval in seconds until Simulation Manager resends an Epoch message if some component has not responded with Status message. The default value is 120 seconds. MaxEpochResendCount Integer 0..1 (OPTIONAL) The maximum number of Epoch message resends Simulation Manager can try. The default value is 5 resends. (a) Date and time included Accuracy 1 ms Time zone information MUST be included","title":"Simulation Manager block"},{"location":"core_msg-start/#log-writer-block","text":"Field Type Multiplicity Explanation MessageBufferMaxDocumentCount Integer (> 0) 1 (OPTIONAL) The maximum number of messages the buffer in Log Writer can hold before the messages are written to the database and the buffer is cleared. The default value is 20. MessageBufferMaxInterval Float 1 (OPTIONAL) The maximum time interval in seconds before the message buffer in Log Writer is cleared and the messages written to the database. The default value is 10 seconds.","title":"Log Writer block"},{"location":"core_msg-start/#dummy-component-block","text":"Field Type Multiplicity Explanation MinSleepTime Float 1 (OPTIONAL) The minimum time in seconds the Dummy component waits after receiving an Epoch message before sending the Status message. The default value is 2 seconds. MaxSleepTime Float 1 (OPTIONAL) The maximum time in seconds the Dummy component waits after receiving an Epoch message before sending the Status message. The default value is 15 seconds. WarningChance Float 1 (OPTIONAL) The probability that a warning is included in the Status message sent to the Simulation Manager. 1 means that a warning is always included and 0 means that a warning is never included. The default value is 0. SendMissChance Float 1 (OPTIONAL) The probability that the Dummy component does not send the Status message after processing the epoch to the simulation manager. 1 means that the Status messages are never sent and 0 means that they are always sent. The default value is 0. ReceiveMissChance Float 1 (OPTIONAL) The probability that the Dummy component ignores a received Epoch message. 1 means that the Epoch messages are always ignored and 0 means that they are never ignored. The default value is 0. ErrorChance Float 1 (OPTIONAL) The probability that the Dummy component sends an error message after a received Epoch message. 1 means that an error message is always sent and 0 means that an error message is never included. The default value is 0.","title":"Dummy Component block"},{"location":"core_msg-status/","text":"Status message JSON structure Ready message { (Fields of AbstractMessage and AbstractResult must appear too!) \"Value\" : \"ready\" } Error message { (Fields of AbstractMessage and AbstractResult must appear too!) \"Value\" : \"error\", \"Description\" : \"Cannot calculate: expected pea soup because it is Thursday\" } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Value String 1 (REQUIRED) The status value being reported. This MUST be one of the following: \"ready\" or \"error\". Description String 0..1 (OPTIONAL) Status description; see (1) (1) If Value is \"ready\", this field SHOULD be omitted. If Value is \"error\", this field SHOULD contain a description what went wrong.","title":"Message - Status"},{"location":"core_msg-status/#status-message","text":"","title":"Status message"},{"location":"core_msg-status/#json-structure","text":"","title":"JSON structure"},{"location":"core_msg-status/#ready-message","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"Value\" : \"ready\" }","title":"Ready message"},{"location":"core_msg-status/#error-message","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"Value\" : \"error\", \"Description\" : \"Cannot calculate: expected pea soup because it is Thursday\" }","title":"Error message"},{"location":"core_msg-status/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Value String 1 (REQUIRED) The status value being reported. This MUST be one of the following: \"ready\" or \"error\". Description String 0..1 (OPTIONAL) Status description; see (1) (1) If Value is \"ready\", this field SHOULD be omitted. If Value is \"error\", this field SHOULD contain a description what went wrong.","title":"Fields and multiplicity"},{"location":"core_msg/","text":"Message structures (core) This page gathers all message structures of the platform core. Type inheritance To save the re-use of specifications and software, the message structures apply inheritance similar to object-oriented programming. This is illustrated in the following figure: AbstractMessage is the base class of all messages All messages MUST inherit fields from this The direct descendants are: SimState AbstractResult AbstractResult represents the result (i.e., output) of a process All messages that carry a result MUST inherit the fields of AbstractResult The direct descendants are at least: Epoch Status All actual result messages Re-usable blocks Certain structures are generic and re-usable in multiple message structures. These are explained in the following table. Structure Description Quantity array block Contains an array of quantity values with a unit of measure. Quantity block Contains a quantity value with a unit of measure. Time series block Contains one or more time series.","title":"Message structures (core)"},{"location":"core_msg/#message-structures-core","text":"This page gathers all message structures of the platform core.","title":"Message structures (core)"},{"location":"core_msg/#type-inheritance","text":"To save the re-use of specifications and software, the message structures apply inheritance similar to object-oriented programming. This is illustrated in the following figure: AbstractMessage is the base class of all messages All messages MUST inherit fields from this The direct descendants are: SimState AbstractResult AbstractResult represents the result (i.e., output) of a process All messages that carry a result MUST inherit the fields of AbstractResult The direct descendants are at least: Epoch Status All actual result messages","title":"Type inheritance"},{"location":"core_msg/#re-usable-blocks","text":"Certain structures are generic and re-usable in multiple message structures. These are explained in the following table. Structure Description Quantity array block Contains an array of quantity values with a unit of measure. Quantity block Contains a quantity value with a unit of measure. Time series block Contains one or more time series.","title":"Re-usable blocks"},{"location":"core_msgtype/","text":"Message type names (core) This page specifies the message type names to appear in messages. I.e., these values should appear in the \"Type\" field of each message. Message Type name (case sensitive) Epoch Epoch SimState SimState Start Start Status Status","title":"Message type names (core)"},{"location":"core_msgtype/#message-type-names-core","text":"This page specifies the message type names to appear in messages. I.e., these values should appear in the \"Type\" field of each message. Message Type name (case sensitive) Epoch Epoch SimState SimState Start Start Status Status","title":"Message type names (core)"},{"location":"core_platformmanager/","text":"PlatformManager TODO! Ville","title":"PlatformManager"},{"location":"core_platformmanager/#platformmanager","text":"TODO! Ville","title":"PlatformManager"},{"location":"core_pseudocode/","text":"Pseudocode reference This page explains how to interpret the pseudocode that appears in some pages. Motivation The principles behind the pseudocode are: Be easily readable Express what is essential Leave freedom of expression, i.e., avoid strict rules What are the advantages? Pseudocode: is more compact than human language does not tie the algorithm to any programming language contains fewer details than source code and therefore: pseudocode is faster to write it's easier to see the overall picture from pseudocode Comments // This is a comment Variables and strings // Declaring a string variable: my_var = \"Example string\" // Concatenation happens as follows. // This will result in \"Example string is nice\" my_var_longer = my_var + \" is nice\" Calculation (calc) // \"calc result\" indicates that the component generates a result to be published. // Often, this includes calculation (such as simulation) // but the component may as well supply a constant value. calc result Messaging (publ, recv) // The component receives a message with some input to calculation. // This does not specify where the input comes from. recv input // Use the input to calculate a result. calc result // Publish the result. // This does not specify the topic to which the result is published. publ result Often, pseudocode does not specify to which topic to publish. This is to avoid redundancy with another page or location that specifies the exact topic. However, if there is a need to specify the topic explicitly, you can say: topic = \"TopicX\" publ result to topic // Alternatively: publ result to \"TopicX\" If conditions (if, else) // Indentation indicates which lines belong to which code block (if and else). if x // This line is executed if condition \"x\" matches else if y // This line is executed if condition \"y\" matches else // This line is executed if none of the earlier conditions matches // This line is executed after the if-else block Looping (loop, break) loop // This line is executed as long as \"break loop\" has not occurred. // Indentation indicates which lines are within the loop. // The loop breaks conditionally. // If there are nested loops, break only affects the innermost loop. if x break loop Wait for events // Wait for one of events to occur first wait for one of recv x // This line is executed if \"recv x\" occurs first recv y // This line is executed if \"recv y\" occurs first recv z // Because there is no indented line after the event \"recv z\", // this causes the execution to jump here. // Still, even the other events will eventually lead here. Quitting (quit) // To quit execution, say: quit Functions Functions are defined as follows: function my_function() // This is some code within the function. // The indentation indicates which lines belong to the function. The function above is called as follows: my_function()","title":"Pseudocode reference"},{"location":"core_pseudocode/#pseudocode-reference","text":"This page explains how to interpret the pseudocode that appears in some pages.","title":"Pseudocode reference"},{"location":"core_pseudocode/#motivation","text":"The principles behind the pseudocode are: Be easily readable Express what is essential Leave freedom of expression, i.e., avoid strict rules What are the advantages? Pseudocode: is more compact than human language does not tie the algorithm to any programming language contains fewer details than source code and therefore: pseudocode is faster to write it's easier to see the overall picture from pseudocode","title":"Motivation"},{"location":"core_pseudocode/#comments","text":"// This is a comment","title":"Comments"},{"location":"core_pseudocode/#variables-and-strings","text":"// Declaring a string variable: my_var = \"Example string\" // Concatenation happens as follows. // This will result in \"Example string is nice\" my_var_longer = my_var + \" is nice\"","title":"Variables and strings"},{"location":"core_pseudocode/#calculation-calc","text":"// \"calc result\" indicates that the component generates a result to be published. // Often, this includes calculation (such as simulation) // but the component may as well supply a constant value. calc result","title":"Calculation (calc)"},{"location":"core_pseudocode/#messaging-publ-recv","text":"// The component receives a message with some input to calculation. // This does not specify where the input comes from. recv input // Use the input to calculate a result. calc result // Publish the result. // This does not specify the topic to which the result is published. publ result Often, pseudocode does not specify to which topic to publish. This is to avoid redundancy with another page or location that specifies the exact topic. However, if there is a need to specify the topic explicitly, you can say: topic = \"TopicX\" publ result to topic // Alternatively: publ result to \"TopicX\"","title":"Messaging (publ, recv)"},{"location":"core_pseudocode/#if-conditions-if-else","text":"// Indentation indicates which lines belong to which code block (if and else). if x // This line is executed if condition \"x\" matches else if y // This line is executed if condition \"y\" matches else // This line is executed if none of the earlier conditions matches // This line is executed after the if-else block","title":"If conditions (if, else)"},{"location":"core_pseudocode/#looping-loop-break","text":"loop // This line is executed as long as \"break loop\" has not occurred. // Indentation indicates which lines are within the loop. // The loop breaks conditionally. // If there are nested loops, break only affects the innermost loop. if x break loop","title":"Looping (loop, break)"},{"location":"core_pseudocode/#wait-for-events","text":"// Wait for one of events to occur first wait for one of recv x // This line is executed if \"recv x\" occurs first recv y // This line is executed if \"recv y\" occurs first recv z // Because there is no indented line after the event \"recv z\", // this causes the execution to jump here. // Still, even the other events will eventually lead here.","title":"Wait for events"},{"location":"core_pseudocode/#quitting-quit","text":"// To quit execution, say: quit","title":"Quitting (quit)"},{"location":"core_pseudocode/#functions","text":"Functions are defined as follows: function my_function() // This is some code within the function. // The indentation indicates which lines belong to the function. The function above is called as follows: my_function()","title":"Functions"},{"location":"core_rabbitmq-reliability/","text":"Reliable messaging in RabbitMQ This page presents RabbitMQ mechanisms to increase the reliability of messaging. This is a summary from https://www.rabbitmq.com/confirms.html . The content has been gathered selectively. Reliable messaging needed in simulations? AMQP connections are based on TCP (Transmission Control Protocol), which guarantees reliability as long as the connection remains open. TCP is considered reliable enough for this platform without any additional mechanims. If the connection dies in a node, the simulation fails anyway and this is detected as soon as notifications about finishing cease appearing. Therefore, it is suggested to use automatic acks in RabbitMQ to reduce the burden of software development. Still, nothing prevents a single developer from enabling additional mechanisms for reliability. Confirmations from consumers Automatic confirmations \"In automatic acknowledgement mode, a message is considered to be successfully delivered immediately after it is sent.\" That is, the broker will not retry if the consumer dies after a message is delivered from a queue to a consumer. However, we still have an underlying TCP connection, which is supposedly reliable as long as it remains open. Manual confirmations If a consumer applies this mode, it MUST acknowledge all deliveries after reception. The mode is more secure compared to automatic acks, but the consumer might still crash after ack. Confirm types ack \"used for positive acknowledgements\" reject \"used for negative acknowledgements\" Signals the broker that \"delivery wasn't processed but still should be deleted\". nack \"used for negative acknowledgements\" This is a RabbitMQ extension to the AMQP protocol. Acks can be batched to reduce traffic. However, because \"reject\" does not support this, nack was introduced in RabbitMQ. Requeue Reject and nack have an option to ask the broker to requeue a non-delivered message. This is controlled with the \"requeue\" field. Channel prefetch The \"basic.qos\" method enables setting the maximum number of messages that the broker can send to a consumer before receiving a confirmation for the first. This protects the consumers from receiving too many messages at once. Confirmations to publishers RabbitMQ implements an extension to AMQP to enable \"publisher confirms\". Although TCP is a reliable protocol, there is a risk that a dead connection is detected only after various minutes (see https://www.rabbitmq.com/heartbeats.html ). Standard AMQP provides a mechanism called transactions, but this reduces throughput.","title":"Reliable messaging in RabbitMQ"},{"location":"core_rabbitmq-reliability/#reliable-messaging-in-rabbitmq","text":"This page presents RabbitMQ mechanisms to increase the reliability of messaging. This is a summary from https://www.rabbitmq.com/confirms.html . The content has been gathered selectively.","title":"Reliable messaging in RabbitMQ"},{"location":"core_rabbitmq-reliability/#reliable-messaging-needed-in-simulations","text":"AMQP connections are based on TCP (Transmission Control Protocol), which guarantees reliability as long as the connection remains open. TCP is considered reliable enough for this platform without any additional mechanims. If the connection dies in a node, the simulation fails anyway and this is detected as soon as notifications about finishing cease appearing. Therefore, it is suggested to use automatic acks in RabbitMQ to reduce the burden of software development. Still, nothing prevents a single developer from enabling additional mechanisms for reliability.","title":"Reliable messaging needed in simulations?"},{"location":"core_rabbitmq-reliability/#confirmations-from-consumers","text":"","title":"Confirmations from consumers"},{"location":"core_rabbitmq-reliability/#automatic-confirmations","text":"\"In automatic acknowledgement mode, a message is considered to be successfully delivered immediately after it is sent.\" That is, the broker will not retry if the consumer dies after a message is delivered from a queue to a consumer. However, we still have an underlying TCP connection, which is supposedly reliable as long as it remains open.","title":"Automatic confirmations"},{"location":"core_rabbitmq-reliability/#manual-confirmations","text":"If a consumer applies this mode, it MUST acknowledge all deliveries after reception. The mode is more secure compared to automatic acks, but the consumer might still crash after ack.","title":"Manual confirmations"},{"location":"core_rabbitmq-reliability/#confirm-types","text":"","title":"Confirm types"},{"location":"core_rabbitmq-reliability/#ack","text":"\"used for positive acknowledgements\"","title":"ack"},{"location":"core_rabbitmq-reliability/#reject","text":"\"used for negative acknowledgements\" Signals the broker that \"delivery wasn't processed but still should be deleted\".","title":"reject"},{"location":"core_rabbitmq-reliability/#nack","text":"\"used for negative acknowledgements\" This is a RabbitMQ extension to the AMQP protocol. Acks can be batched to reduce traffic. However, because \"reject\" does not support this, nack was introduced in RabbitMQ.","title":"nack"},{"location":"core_rabbitmq-reliability/#requeue","text":"Reject and nack have an option to ask the broker to requeue a non-delivered message. This is controlled with the \"requeue\" field.","title":"Requeue"},{"location":"core_rabbitmq-reliability/#channel-prefetch","text":"The \"basic.qos\" method enables setting the maximum number of messages that the broker can send to a consumer before receiving a confirmation for the first. This protects the consumers from receiving too many messages at once.","title":"Channel prefetch"},{"location":"core_rabbitmq-reliability/#confirmations-to-publishers","text":"RabbitMQ implements an extension to AMQP to enable \"publisher confirms\". Although TCP is a reliable protocol, there is a risk that a dead connection is detected only after various minutes (see https://www.rabbitmq.com/heartbeats.html ). Standard AMQP provides a mechanism called transactions, but this reduces throughput.","title":"Confirmations to publishers"},{"location":"core_run/","text":"Running a simulation TODO! (Ville)","title":"Run simulation"},{"location":"core_run/#running-a-simulation","text":"TODO! (Ville)","title":"Running a simulation"},{"location":"core_sim-tools/","text":"Simulation Tools package To reduce redundant development work, the package Simulation Tools implements re-usable software modules. The package has been implemented in Python. For example, Simulation Tools includes following features: Classes for reading and creating messages, such as Epoch and Status Classes for creating domain-specific messages from AbstractMessage and AbstractResult Classes for processing re-usable message blocks, such as QuantityBlock and TimeSeriesBlock Network client class An abstract base class with the common functionality of simulation components Class for processing datetime values in ISO 8601 Class for logging (locally within the component) Timer class TODO: Where to get this? Link to public Git repo?","title":"Simulation Tools package"},{"location":"core_sim-tools/#simulation-tools-package","text":"To reduce redundant development work, the package Simulation Tools implements re-usable software modules. The package has been implemented in Python. For example, Simulation Tools includes following features: Classes for reading and creating messages, such as Epoch and Status Classes for creating domain-specific messages from AbstractMessage and AbstractResult Classes for processing re-usable message blocks, such as QuantityBlock and TimeSeriesBlock Network client class An abstract base class with the common functionality of simulation components Class for processing datetime values in ISO 8601 Class for logging (locally within the component) Timer class TODO: Where to get this? Link to public Git repo?","title":"Simulation Tools package"},{"location":"core_simulationmanager/","text":"SimulationManager TODO! Ville","title":"SimulationManager"},{"location":"core_simulationmanager/#simulationmanager","text":"TODO! Ville","title":"SimulationManager"},{"location":"core_soa/","text":"Service-oriented architecture The simulation platform aims at facilitating the design and maintenance of components, so each developer SHOULD follow the principles of Service-oriented Architecture (SOA). SOA aims to realize a world where the pieces of systems are abstract services with few dependencies. In some cases, SOA can increase the work required to design an individual component, but this is compensated with easier maintenance and scalability during the lifecycle of the system. SOA has a number of principles that the developers should follow. The following apply in the simulation platform. Loose coupling \"ensure that the service contract is not tightly coupled to the service consumers and to the underlying service logic and implementation\" https://en.wikipedia.org/wiki/Service_loose_coupling_principle -> Do not let product- or runtime-specific features be visible in interfaces! Abstraction \"information published in a service contract is limited to what is required to effectively utilize the service\" https://en.wikipedia.org/wiki/Service_abstraction Reusability \"to create services that can be reused across a business\" https://en.wikipedia.org/wiki/Service_reusability_principle Composability \"can be reused in multiple solutions that are themselves made up of composed services\" https://en.wikipedia.org/wiki/Service_composability_principle Autonomy \"to provide services with improved independence from their execution environments\" https://en.wikipedia.org/wiki/Service_autonomy_principle -> Do not let product- or runtime-specific features be visible in interfaces! Standized service contract \"service contracts within a service inventory (enterprise or domain) adhere to the same set of design standards\" https://en.wikipedia.org/wiki/Standardized_service_contract","title":"Service-oriented architecture"},{"location":"core_soa/#service-oriented-architecture","text":"The simulation platform aims at facilitating the design and maintenance of components, so each developer SHOULD follow the principles of Service-oriented Architecture (SOA). SOA aims to realize a world where the pieces of systems are abstract services with few dependencies. In some cases, SOA can increase the work required to design an individual component, but this is compensated with easier maintenance and scalability during the lifecycle of the system. SOA has a number of principles that the developers should follow. The following apply in the simulation platform.","title":"Service-oriented architecture"},{"location":"core_soa/#loose-coupling","text":"\"ensure that the service contract is not tightly coupled to the service consumers and to the underlying service logic and implementation\" https://en.wikipedia.org/wiki/Service_loose_coupling_principle -> Do not let product- or runtime-specific features be visible in interfaces!","title":"Loose coupling"},{"location":"core_soa/#abstraction","text":"\"information published in a service contract is limited to what is required to effectively utilize the service\" https://en.wikipedia.org/wiki/Service_abstraction","title":"Abstraction"},{"location":"core_soa/#reusability","text":"\"to create services that can be reused across a business\" https://en.wikipedia.org/wiki/Service_reusability_principle","title":"Reusability"},{"location":"core_soa/#composability","text":"\"can be reused in multiple solutions that are themselves made up of composed services\" https://en.wikipedia.org/wiki/Service_composability_principle","title":"Composability"},{"location":"core_soa/#autonomy","text":"\"to provide services with improved independence from their execution environments\" https://en.wikipedia.org/wiki/Service_autonomy_principle -> Do not let product- or runtime-specific features be visible in interfaces!","title":"Autonomy"},{"location":"core_soa/#standized-service-contract","text":"\"service contracts within a service inventory (enterprise or domain) adhere to the same set of design standards\" https://en.wikipedia.org/wiki/Standardized_service_contract","title":"Standized service contract"},{"location":"core_time/","text":"Time and synchronization with epochs The simulator components are distributed but should still simulate together, which necessitates a mechanism to synchronize time. This is implemented with epochs . An epoch represents a period of simulated time, e.g., today between 12:00 and 12:15 p.m. The length of epoch can be varied depending on the desired resolution of simulation. As epochs always represent simulated time, the duration is different in real time. This depends mainly on how fast the slowest component can simulate. For all epochs it holds that (\"Eno\" is the ordinal number of the epoch): epoch.StartTime < epoch.EndTime epoch'.Eno = epoch.Eno + 1 => epoch'.StartTime = epoch.EndTime In simulation, the first epoch has Eno = 1 Within epoch, epoch.StartTime is included, whereas epoch.EndTime is excluded To start an epoch, the platform publishes an epoch message. Once the components receive this, they have a permission to start calculating their result for the current epoch. Some components can additionally require data from other components during the epoch, which affects when the calculation can occur. Once a component has published its result, it publishes a \"ready\" message to inform the platform that it has nothing more to do during the epoch. Once the platform has received a ready message from all components, the next epoch can start. This means that the simulation runs with best effort and one component is always the bottleneck. The following figure illustrates how an epoch message is delivered to components. There are components C1-C4. As the platform publishes an epoch message, this is delivered to all components to signal what time period is to be simulated. The following figure illustrates how components communicate their results and readiness once an epoch has started. Each component publishes a result (res1-res4) and reports it has finished by publishing a ready message (rd1-rd4). However, certain components need the result of another component to calculate their result. In the figure, C3 can only proceed once it has the result of C1 and C2, and C4 needs the result of C2 and C3, respectively. That is, some components in this example execute sequentially. In the figures above, the messages are published as follows: Platform publishes an epoch message and delivers this to C1, C2, C3 and C4 The following workflows occur in parallel: C1 Publish res1 Publish rd1 C2 Publish res2 Publish rd2 C3 Wait until res1 and res2 have been received Publish res3 Publish rd3 C4 Wait until res2 and res3 have been received Publish rd4","title":"Time and synchronization with epochs"},{"location":"core_time/#time-and-synchronization-with-epochs","text":"The simulator components are distributed but should still simulate together, which necessitates a mechanism to synchronize time. This is implemented with epochs . An epoch represents a period of simulated time, e.g., today between 12:00 and 12:15 p.m. The length of epoch can be varied depending on the desired resolution of simulation. As epochs always represent simulated time, the duration is different in real time. This depends mainly on how fast the slowest component can simulate. For all epochs it holds that (\"Eno\" is the ordinal number of the epoch): epoch.StartTime < epoch.EndTime epoch'.Eno = epoch.Eno + 1 => epoch'.StartTime = epoch.EndTime In simulation, the first epoch has Eno = 1 Within epoch, epoch.StartTime is included, whereas epoch.EndTime is excluded To start an epoch, the platform publishes an epoch message. Once the components receive this, they have a permission to start calculating their result for the current epoch. Some components can additionally require data from other components during the epoch, which affects when the calculation can occur. Once a component has published its result, it publishes a \"ready\" message to inform the platform that it has nothing more to do during the epoch. Once the platform has received a ready message from all components, the next epoch can start. This means that the simulation runs with best effort and one component is always the bottleneck. The following figure illustrates how an epoch message is delivered to components. There are components C1-C4. As the platform publishes an epoch message, this is delivered to all components to signal what time period is to be simulated. The following figure illustrates how components communicate their results and readiness once an epoch has started. Each component publishes a result (res1-res4) and reports it has finished by publishing a ready message (rd1-rd4). However, certain components need the result of another component to calculate their result. In the figure, C3 can only proceed once it has the result of C1 and C2, and C4 needs the result of C2 and C3, respectively. That is, some components in this example execute sequentially. In the figures above, the messages are published as follows: Platform publishes an epoch message and delivers this to C1, C2, C3 and C4 The following workflows occur in parallel: C1 Publish res1 Publish rd1 C2 Publish res2 Publish rd2 C3 Wait until res1 and res2 have been received Publish res3 Publish rd3 C4 Wait until res2 and res3 have been received Publish rd4","title":"Time and synchronization with epochs"},{"location":"core_topics-queues-exchanges/","text":"Communication with topics, queues and exchanges The simulation platform communicates in a publish-subscribe fashion to realize loose coupling. This means that the components do not directly request anything from each other but rather announce which information they are interested in. Then, the platform delivers this information. Advantages: The sender/producer does not need to know which receivers/consumers gets the message. All interested consumers get it. The consumer does not need to know the sender - only the type of data. The consumer does not need to process the incoming immediately, the message can stay in the queue until the consumer has time to process it. This is sometimes called store-and-forward paradigm. Topics and queues Publish-subscribe communication is implemented with a message bus that routes messages with topics and message queues. A topic is a string that identifies a subject of interest. Any piece of software can publish to the topic, and any piece of software can subscribe to receive messages from the topic. To receive messages, each subscriber creates a message queue and associates this to one or more topics. The motivation of queues is to enable asynchronous message processing, as the recipient can delay message reception without blocking any other node. Each topic can have an arbitrary number of subscriber queues associated. If a topic has no subscribers, no one receives message from the topic. Respectively, if there are multiple subscribers, the message bus clones each message for each subscriber. The following figure illustrates message routing with topics and queues. The message bus manages the topics and queues. There is one topic called \"LivingRoom.Temperature.T1\", and subscribers Y and Z have created and associated a message queue. Whenever publisher X publishes to the topic, the message bus deliver this message to both queues. Subscribers Y and Z can receive messages from their queue when they have time. Meanwhile, any messages remain in the queue. Exchanges To implement the message bus, the simulation platform uses AMQP 0-9-1 as the protocol and RabbitMQ as the product. Topic-based communication is only one communication mode in AMQP 0-9-1, but the others are irrelevant here. In addition, please note that AMQP has multiple versions that are mutually incompatible. In AMQP 0-9-1, each topic resides in an exchange. Exchanges can realize a sandbox that isolates topics from each other. This is a useful mechanism, for example, when the intention is to run concurrent simulations in the same platform. The platform specifies two types of exchange: Simulation-specific exchange. The platform creates one for each simulation run, as this prevents any interference between simulation runs and enables even concurrent simulations. Management exchange. There is only one of these. The management exchange is there to enable communication with components even when no simulation is running. The details of these exchanges are explained in the page Exchanges. Hierarchical topic names and wildcards In AMQP 0-9-1, a topic name can be hierarchical. In this case, the hierarchy levels are separated by periods, such as \"LivingRoom.Temperature.T1\", \"LivingRoom.Temperature.T2\" and \"LivingRoom.Humidity.H1\" for a sensor system in a residence. When subscribing for an AMQP topic, you can use wildcards if appropriate. These are '*' for a single hierarchy level and '#' for any number of levels. The subscription can be, for example: \"LivingRoom.#\" for all sensors in the living room \"*.Temperature.#\" for all temperature sensors in the residence It is notable, however, that naming must be systematic to allow wildcards to work.","title":"Topics, queues and exchanges"},{"location":"core_topics-queues-exchanges/#communication-with-topics-queues-and-exchanges","text":"The simulation platform communicates in a publish-subscribe fashion to realize loose coupling. This means that the components do not directly request anything from each other but rather announce which information they are interested in. Then, the platform delivers this information. Advantages: The sender/producer does not need to know which receivers/consumers gets the message. All interested consumers get it. The consumer does not need to know the sender - only the type of data. The consumer does not need to process the incoming immediately, the message can stay in the queue until the consumer has time to process it. This is sometimes called store-and-forward paradigm.","title":"Communication with topics, queues and exchanges"},{"location":"core_topics-queues-exchanges/#topics-and-queues","text":"Publish-subscribe communication is implemented with a message bus that routes messages with topics and message queues. A topic is a string that identifies a subject of interest. Any piece of software can publish to the topic, and any piece of software can subscribe to receive messages from the topic. To receive messages, each subscriber creates a message queue and associates this to one or more topics. The motivation of queues is to enable asynchronous message processing, as the recipient can delay message reception without blocking any other node. Each topic can have an arbitrary number of subscriber queues associated. If a topic has no subscribers, no one receives message from the topic. Respectively, if there are multiple subscribers, the message bus clones each message for each subscriber. The following figure illustrates message routing with topics and queues. The message bus manages the topics and queues. There is one topic called \"LivingRoom.Temperature.T1\", and subscribers Y and Z have created and associated a message queue. Whenever publisher X publishes to the topic, the message bus deliver this message to both queues. Subscribers Y and Z can receive messages from their queue when they have time. Meanwhile, any messages remain in the queue.","title":"Topics and queues"},{"location":"core_topics-queues-exchanges/#exchanges","text":"To implement the message bus, the simulation platform uses AMQP 0-9-1 as the protocol and RabbitMQ as the product. Topic-based communication is only one communication mode in AMQP 0-9-1, but the others are irrelevant here. In addition, please note that AMQP has multiple versions that are mutually incompatible. In AMQP 0-9-1, each topic resides in an exchange. Exchanges can realize a sandbox that isolates topics from each other. This is a useful mechanism, for example, when the intention is to run concurrent simulations in the same platform. The platform specifies two types of exchange: Simulation-specific exchange. The platform creates one for each simulation run, as this prevents any interference between simulation runs and enables even concurrent simulations. Management exchange. There is only one of these. The management exchange is there to enable communication with components even when no simulation is running. The details of these exchanges are explained in the page Exchanges.","title":"Exchanges"},{"location":"core_topics-queues-exchanges/#hierarchical-topic-names-and-wildcards","text":"In AMQP 0-9-1, a topic name can be hierarchical. In this case, the hierarchy levels are separated by periods, such as \"LivingRoom.Temperature.T1\", \"LivingRoom.Temperature.T2\" and \"LivingRoom.Humidity.H1\" for a sensor system in a residence. When subscribing for an AMQP topic, you can use wildcards if appropriate. These are '*' for a single hierarchy level and '#' for any number of levels. The subscription can be, for example: \"LivingRoom.#\" for all sensors in the living room \"*.Temperature.#\" for all temperature sensors in the residence It is notable, however, that naming must be systematic to allow wildcards to work.","title":"Hierarchical topic names and wildcards"},{"location":"core_topics/","text":"Topics (core) The following table lists the topic names used by the core platform and which message type occurs in each topic. The table below is normative. This means that if any other page has a conflicting topic name, this table has the precedence. Topic name Message type Purpose (see 1) Exchange (see 2) Publisher(s) Subscriber(s) Motivation Epoch Epoch Reporting S SimulationManager (All non-core components) Coordinating execution of epochs SimState SimState Reporting S SimulationManager (All non-core components) Controlling execution of simulation Start Start Starting M PlatformManager (All externally managed non-core components) Signalling start of simulation; deliver parameters Status.Error Status Reporting S (Any non-core component) SimulationManager Error reporting Status.Ready Status Reporting S (Any non-core component) SimulationManager Reporting readiness to start next epoch (1) Purposes: Starting: starting a simulation run (once for each simulation run) Reporting: communication of data during simulation (multiple times during a simulation run) (2) Exchanges: M: Management Exchange S: Simulation-specific Exchange","title":"Topics (core)"},{"location":"core_topics/#topics-core","text":"The following table lists the topic names used by the core platform and which message type occurs in each topic. The table below is normative. This means that if any other page has a conflicting topic name, this table has the precedence. Topic name Message type Purpose (see 1) Exchange (see 2) Publisher(s) Subscriber(s) Motivation Epoch Epoch Reporting S SimulationManager (All non-core components) Coordinating execution of epochs SimState SimState Reporting S SimulationManager (All non-core components) Controlling execution of simulation Start Start Starting M PlatformManager (All externally managed non-core components) Signalling start of simulation; deliver parameters Status.Error Status Reporting S (Any non-core component) SimulationManager Error reporting Status.Ready Status Reporting S (Any non-core component) SimulationManager Reporting readiness to start next epoch (1) Purposes: Starting: starting a simulation run (once for each simulation run) Reporting: communication of data during simulation (multiple times during a simulation run) (2) Exchanges: M: Management Exchange S: Simulation-specific Exchange","title":"Topics (core)"},{"location":"core_ucum/","text":"Units of measure (UCUM) What is UCUM and why? There are multiple ways to specify a unit of measure in a software-interpretable message, which can cause incompatibility. It is not always clear what a particular symbol means. For example, \"C\" could refer to \"Celsius\" or \"Coulomb\", and a human being could come up multiple ways to express Celsius values, such as: \"C\", \"deg_C\", \"DegC\", \"Cel\" or \"Celsius\". Even if a human reader understood the meaning, this often does not apply to software. In principle, this challenge applies to any unit of measure. This is what The Unified Code for Units of Measure (UCUM) is for. UCUM is introduced as follows (from https://ucum.org/trac ): The Unified Code for Units of Measure (UCUM) is a code system intended to include all units of measures being contemporarily used in international science, engineering, and business. The purpose is to facilitate unambiguous electronic communication of quantities together with their units. The focus is on electronic communication, as opposed to communication between humans. The Unified Code for Units of Measures -- has already been adopted by some standard organizations such as DICOM, HL7 and has been referenced as best practice by the Open Geospatial Consortium in their Web Map Service (WMS) and Geography Markup Language (GML) implementation specifications. UCUM is not the first specification to encode units of measure. However, UCUM is the best solution known to exist. The advantages include: openly available at no cost coverage (in principle, you can express any unit of measure in the world) human-readability and intuitiveness (in contrast to some specifications that use numeric identifiers, such as UNECE: http://tfig.unece.org/contents/recommendation-20.htm) UCUM in SimCES All fields that express a unit of measure SHOULD comply with the case-sensitive UCUM format (see https://ucum.org/ucum.html ). In the tables of UCUM specification, these are defined in the column \"c/s\". Units possibly beneficial in simulation UCUM is not limited to these units, but these can be beneficial. Category Name UCUM presentation Comment General per unit {pu} The unit is effectively \"1\", which is the default unit. However, curly braces enclose an annotation that elaborates what the value means. \"EUR\" is a currency code standardized in ISO 4217. Current ampere A Energy megawatt hour MW.h Percentage Percentage % Power (apparent) kilovolt ampere kV.A Power (reactive) kilovolt ampere (reactive) kV.A{r} Power (real) megawatt MW Price per megawatt hour {EUR}/(MW.h) Currencies are not supported in UCUM. Therefore, \"EUR\" is merely an annotation here (i.e., in curly brackets) and means \"1\". Temperature celsius Cel Voltage kilovolt kV Unit rules Basic UCUM writes many of the typical units as we would think. E.g.:, meter: \"m\", second: \"s\", Joule: \"J\". However, some unit can cause ambiquity and therefore have another definition. E.g.: Celsius: \"Cel\", pH: \"[pH]\". Prefixes Prefixes are supported. E.g.: tera: \"T\", mega: \"M\", kilo: \"k\". More prefixes: see \u00a727 \"prefixes\" at https://ucum.org/ucum.html#para-27 . Square brackets At https://ucum.org/ucum.html#para-14 : \u00a714 square brackets. Square brackets enclose suffixes of unit symbols that change the meaning of a unit stem. For example: UCUM c/s presentation Meaning mm[Hg] millimeter Mercury column [ppm] Parts per million Curly braces At https://ucum.org/ucum.html#para-12 : \u00a712 curly braces. Curly braces may be used to enclose annotations that are often written in place of units or behind units but that do not have a proper meaning of a unit and do not change the meaning of a unit. For example one can write \u201c%{vol}\u201d, \u201ckg{total}\u201d, or \u201c{RBC}\u201d (for \u201cred blood cells\u201d) as pseudo-units. However, these annotations do not have any effect on the semantics, which is why these example expressions are equivalent to \u201c%\u201d, \u201ckg\u201d, and \u201c1\u201d respectively.","title":"Units of measure (UCUM)"},{"location":"core_ucum/#units-of-measure-ucum","text":"","title":"Units of measure (UCUM)"},{"location":"core_ucum/#what-is-ucum-and-why","text":"There are multiple ways to specify a unit of measure in a software-interpretable message, which can cause incompatibility. It is not always clear what a particular symbol means. For example, \"C\" could refer to \"Celsius\" or \"Coulomb\", and a human being could come up multiple ways to express Celsius values, such as: \"C\", \"deg_C\", \"DegC\", \"Cel\" or \"Celsius\". Even if a human reader understood the meaning, this often does not apply to software. In principle, this challenge applies to any unit of measure. This is what The Unified Code for Units of Measure (UCUM) is for. UCUM is introduced as follows (from https://ucum.org/trac ): The Unified Code for Units of Measure (UCUM) is a code system intended to include all units of measures being contemporarily used in international science, engineering, and business. The purpose is to facilitate unambiguous electronic communication of quantities together with their units. The focus is on electronic communication, as opposed to communication between humans. The Unified Code for Units of Measures -- has already been adopted by some standard organizations such as DICOM, HL7 and has been referenced as best practice by the Open Geospatial Consortium in their Web Map Service (WMS) and Geography Markup Language (GML) implementation specifications. UCUM is not the first specification to encode units of measure. However, UCUM is the best solution known to exist. The advantages include: openly available at no cost coverage (in principle, you can express any unit of measure in the world) human-readability and intuitiveness (in contrast to some specifications that use numeric identifiers, such as UNECE: http://tfig.unece.org/contents/recommendation-20.htm)","title":"What is UCUM and why?"},{"location":"core_ucum/#ucum-in-simces","text":"All fields that express a unit of measure SHOULD comply with the case-sensitive UCUM format (see https://ucum.org/ucum.html ). In the tables of UCUM specification, these are defined in the column \"c/s\".","title":"UCUM in SimCES"},{"location":"core_ucum/#units-possibly-beneficial-in-simulation","text":"UCUM is not limited to these units, but these can be beneficial. Category Name UCUM presentation Comment General per unit {pu} The unit is effectively \"1\", which is the default unit. However, curly braces enclose an annotation that elaborates what the value means. \"EUR\" is a currency code standardized in ISO 4217. Current ampere A Energy megawatt hour MW.h Percentage Percentage % Power (apparent) kilovolt ampere kV.A Power (reactive) kilovolt ampere (reactive) kV.A{r} Power (real) megawatt MW Price per megawatt hour {EUR}/(MW.h) Currencies are not supported in UCUM. Therefore, \"EUR\" is merely an annotation here (i.e., in curly brackets) and means \"1\". Temperature celsius Cel Voltage kilovolt kV","title":"Units possibly beneficial in simulation"},{"location":"core_ucum/#unit-rules","text":"","title":"Unit rules"},{"location":"core_ucum/#basic","text":"UCUM writes many of the typical units as we would think. E.g.:, meter: \"m\", second: \"s\", Joule: \"J\". However, some unit can cause ambiquity and therefore have another definition. E.g.: Celsius: \"Cel\", pH: \"[pH]\".","title":"Basic"},{"location":"core_ucum/#prefixes","text":"Prefixes are supported. E.g.: tera: \"T\", mega: \"M\", kilo: \"k\". More prefixes: see \u00a727 \"prefixes\" at https://ucum.org/ucum.html#para-27 .","title":"Prefixes"},{"location":"core_ucum/#square-brackets","text":"At https://ucum.org/ucum.html#para-14 : \u00a714 square brackets. Square brackets enclose suffixes of unit symbols that change the meaning of a unit stem. For example: UCUM c/s presentation Meaning mm[Hg] millimeter Mercury column [ppm] Parts per million","title":"Square brackets"},{"location":"core_ucum/#curly-braces","text":"At https://ucum.org/ucum.html#para-12 : \u00a712 curly braces. Curly braces may be used to enclose annotations that are often written in place of units or behind units but that do not have a proper meaning of a unit and do not change the meaning of a unit. For example one can write \u201c%{vol}\u201d, \u201ckg{total}\u201d, or \u201c{RBC}\u201d (for \u201cred blood cells\u201d) as pseudo-units. However, these annotations do not have any effect on the semantics, which is why these example expressions are equivalent to \u201c%\u201d, \u201ckg\u201d, and \u201c1\u201d respectively.","title":"Curly braces"},{"location":"core_workflow-sim/","text":"Workflow of component in simulation This page explains the workflow a component is expected to follow during a simulation run, excluding the start and end of a simulation run. How to read this page Some sections in this page use pseudocode. For reference, see Pseudocode reference . Each pseudocode block is explained in text. The pseudocode is always the primary specification. That is, if the pseudocode conflicts with the text, the pseudocode has preference because the text is merely elaborative. The following apply in all pseudocode blocks of this page. Item in pseudocode Meaning publ error Publish a Status message that indicates an error to \"Status.Error\" publ ready Publish a Status message that indicates readiness to \"Status.Ready\" topic recv epoch From \"Epoch\" topic, receive an Epoch message recv input Receive input for calculation. This does not specify the topic the input comes from. recv running From \"SimState\" topic, receive a SimState message with state \"running\" recv stop From \"SimState\" topic, receive a SimState message with state \"stopped\" Handling simulation state and epochs recv running publ ready first_epoch = true loop wait for one of recv stop quit recv epoch // Include this if block only when implementing an initialization workflow if first_epoch first_epoch = false // Reach this block only once // Run initialization workflow run_initialization_workflow() // Run calculation workflow run_calculation_workflow() The workflow start with the reception of the state message \"running\". Then, the component announces it is ready to start by publishing \"ready\". Once all components have announced they are ready, the platform starts the actual epochs of simulation. In each epoch, the component first awaits an epoch message. However, if the platform instructs the component to stop during this wait, the component will quit. In epoch 1, the component MAY start with an initialization workflow. This means that the component communicates some parameters with other components. Regardless if an initialization workflow took place or not, the component continues to the calculation workflow. Next, the component awaits another epoch to begin. Initialization workflow Initialization workflow is an OPTIONAL step in epoch 1. In this workflow, the component communicates some information with other components before starting the calculation workflow. The component developer decides the following about the initialization workflow depending on the needs: What information is communicated How many components are involved Which messages are published Which components receive the published messages Whether each component should only receive, only publish or both receive and publish messages If the component implements an initialization workflow, this: MUST occur in epoch 1 MUST occur exactly once in each simulation run MUST occur as the first task the component accomplishes in the epoch Topic names Any topic name involved in the initialization workflow MUST start with \"Init.\". To prevent confusion in the processing of messages, a topic name involved in the calculation workflow of any component MUST NOT be involved in the initialization workflow of any component. Publish In this example, the component publishes a message in the initialization workflow. This is appropriate if the component has some information the other components need. function run_initialization_workflow() publish init_info to topic \"Init.Xyz\" Receive In this example, the component receives a message in the initialization workflow. This is appropriate if the component needs some information from another component. function run_initialization_workflow() recv init_info from topic \"Init.Xyz\" Calculation workflow This section describes the rules of interaction for components within one epoch. Although the word \"calculation\" appears in the title, the component does not necessarily calculate anything. If appropriate, the component may as well supply predefined values from a time series, for instance. The calculation workflow takes place after each reception of an epoch message. That is, this excludes the reception of the epoch message! REQUIRED items function run_calculation_workflow() // 1. Calculate whatever you want. Communicate with other components as needed. // ... // 2. Report readiness publ ready When a component has finished its operation in the epoch, it MUST send a ready message. This is the sole requirement set by the platform. A particular simulation scenario CAN set further requirements to enable the components to interact, but these are beyond the core functionality of the platform. Send in Every Epoch A component MAY publish results (i.e., output data) as the developers consider appropriate, but there is a rule called \"Send in Every Epoch\" (SIEE). This means that the component SHOULD be predictable in its publishing behaviour. For example, let component C have the capability to publish a result of type R. If C publishes an R in any epoch, it SHOULD publish an R in all epochs during the simulation run. The motivation is that the other components may not know when to expect R and when not. Therefore, it is most straightforward to always publish an R. Depending on the simulation scenario, the data enclosed in R can remain unchanged between certain epochs. For instance, if the resolution of a timeseries is 60 minutes and epoch length 15 minutes, a change will occur only in every fourth epoch. To follow the SIEE rule, C would re-send the same result data again when no changes have occurred. To help other components in saving resources and possibly avoid redundant calculation, C SHOULD assign the value of the field \"LastUpdatedInEpoch\" to indicate when the most recent change has occurred (see AbstractResult ). Still, C MUST update the other metadata as specified in page AbstractResult . Without input data This is an OPTIONAL workflow. It is applicable when no input data is needed for calculation. function run_calculation_workflow() calc result publ result publ ready The component calculates a result and publishes this. What is calculated and how and to which topic it is published depends on the component. Finally, the component reports readiness. With input data This is an OPTIONAL workflow. It is applicable when input data is necessary for calculation. function run_calculation_workflow() wait for one of recv stop quit recv input calc result publ result publ ready Before calculation, the component waits for input data. If it the platform instruct the component to stop while waiting, the execution will end. After receiving the data, to component calculates and publishes a result. What this result is and to which topic it is published depends on the component. Iterative calculation during epoch Basic rules When components run an iterative algorithm during an epoch, the related functionality must be designed carefully. Iteration MUST NOT be infinite, because this would cause the simulation to get stuck. Therefore, iteration MUST be designed in one of the following ways: (a) There is a guarantee that the algorithm always converges eventually (b) If convergence cannot be guaranteed, the component MUST use another mechanism to end iteration when convergence does not occur Alternative (b) MAY require that the iterating component still publishes a reasonable result. This result MAY be: (h) A default value (i) A value calculated with a simpler algorithm (j) Anything else considered appropriate The way to guarantee a reasonable result is case-specific and therefore out of scope of the core platform. This means that the component developers MUST recognize this need on their own and design an appropriate mechanism. Multi-component iteration Multi-component schemes Iteration MAY include multiple components. This means that one or more components form one or more groups where the components both produce input data to one another and consume the result data of one another. When multi-component iteration occurs, the component developers MUST take care that the iteration ends eventually. To ensure this, the component developers MUST assign each iterating component a role of either active or passive iterator: Active iterators . Each iteration group MUST include at least one active iterator component that has the ability to decide when to end iteration. Passive iterators . In a group of iterators, all components that are not active iterators are passive. These do not actively decide when to end iteration but know that they are involved in iteration. Passive iterators MUST understand the decision of an active iterator to end. The following figure illustrates a few of the potential iteration schemes. In the figure, each arrow represents how each component supplies results that are the input data of another component. The schemes include: (A) A cycle of two components, one active and one passive (B) A cycle of three components, one active and two passive (C) A cycle of three components, two active and one passive If any active iterator decides to end iteration, the result messages will deliver this information to all (D) Two iteration cycles both of which have X as the active iterator; these cycles may operate independently if wanted Still, the scheme MAY be even more complex, that is, contain more components and more cycles. Messaging in iteration In a multi-component iteration scheme, all iterating components MUST communicate the status of iteration in each result message. The component MUST indicate this in two ways: (1) Using the field \"IterationStatus\" (see AbstractMessage ) and (2) Using the suffix \".Iter\" in topic name when the result is intermediate and omitting this suffix when the result is final Please see the naming conventions in page Conventions of naming Together, conditions (1) and (2) ensure a uniform way to communicate which of the messages represent intermediate results and which are final. This has at least the following uses: During a simulation, enable a component to receive only final results when it does not participate in iteration After simulation, enable the separation of intermediate and final results in the retrieval of logged data The following tables tells how active and passive iterators decide whether to continue iteration. An active iterator continues iteration as long as it wants and no other iterator has declared its output as \"final\". In contrast, a passive iterator never decides when to end but instead re-uses the iteration status it has received in input. Active iterator: Does the iterator want to iterate still? IterationStatus received in input data IterationStatus to assign to result message Yes Intermediate Intermediate (iteration continues) Yes Final Final (iteration ends) No Intermediate Final (iteration ends) No Final Final (iteration ends) Passive iterator: IterationStatus received in input data IterationStatus to assign to result message Intermediate Intermediate (iteration continues) Final Final (iteration ends) Active iterator workflow The following code shows the basic workflow that an active iterator MAY implement for epochs. This assumes that the iterator receives exactly one result message as the input. topic = \"TopicX\" // Just an example loop // Loop to enable iteration wait for one of recv stop quit input = recv input iter_status = decide my iter status topic_temp = topic // Iter status is final if this iterator wants it or // if the input data is final if input.iter_status is final iter_status = final if iter_status is not final topic_temp = topic_temp + \".Iter\" result = calc result result.iter_status = iter_status publ result to topic_temp if iter_status is final publ ready break loop Passive iterator workflow The following code shows the basic workflow that a passive iterator MAY implement for epochs. This assumes that the iterator receives exactly one result message as the input. topic = \"TopicY\" // Just an example loop // Loop to enable iteration wait for one of recv stop quit input = recv input topic_temp = topic if input.iter_status is not final topic_temp = topic_temp + \".Iter\" calc result result.iter_status = input.iter_status publ result to topic_temp if input.iter_status is final publ ready break loop Error handling Error is a condition that the component cannot recover from. This happens when, e.g., the component receives a message it should use in calculation but the message is malformed or when there is a bug in the component that prevents further execution. Each component SHOULD be designed to detect errors. Fortunately, modern software languages have mechanisms, such as exceptions, that enable straightforward error handling. Regardless of the mechanism, the component SHOULD be ready to encounter an error anywhere in the code. Such error handling facilitates the tracking of bugs, which inevitably occur in software. Carefully implemented error handling reduces the time required for development. Not all errors can be communicated. For example, the network can be out of reach or the component can run out of memory. However, it is common that communication is still possible regardless of an error. In case an error occurs in a component, the platform has been designed to work as follows: The component reports the error The platform signals all components to stop and will publish no more epoch messages I.e., all components MUST quit If another component is busy on calculation when the stop message arrives, it MAY continue to produce a result and publish this before quitting The following explains how a component SHOULD behave when it has encountered an error. The component immediately publishes an error message (see section how to read). Now, the component waits for the platform to stop the simulation. However, if the component receives another message instead (likely the result of another component or an epoch message), it will re-publish the error message. loop publ error wait for one of recv stop quit recv epoch recv input // From here, the execution will jump to start of loop Warnings A warning means that something is wrong in the logic of a process, but this can still produce something meaningful as the result. Possible causes for warnings include, for instance: Invalid or unrealistic input data Failure to converge the calculation Warnings are informative but not fatal. Still, the presence of a warning in a message MAY cause a fatal condition in another process. When a warning occurs, the process MAY, depending on the situation: Supply default values as the result Execute a secondary calculation logic to have some result Execute its primary calculation logic, although the result can be unreliable How to indicate warning When a component thinks a warning has occurred, it SHOULD indicate this in the result message. Please see AbstractResult . Logging Each component SHOULD have an internal log to help in development and debugging. The reason is that it can be difficult to include all relevant information in the messages that indicate errors or warnings. The log SHOULD contain at least: Error information (such as stack trace if the platform generates exceptions) Warning information The log MAY contain: Entries about the execution of the component, such a steps of the internal workflow Any other information considered relevant","title":"Workflow of component in simulation"},{"location":"core_workflow-sim/#workflow-of-component-in-simulation","text":"This page explains the workflow a component is expected to follow during a simulation run, excluding the start and end of a simulation run.","title":"Workflow of component in simulation"},{"location":"core_workflow-sim/#how-to-read-this-page","text":"Some sections in this page use pseudocode. For reference, see Pseudocode reference . Each pseudocode block is explained in text. The pseudocode is always the primary specification. That is, if the pseudocode conflicts with the text, the pseudocode has preference because the text is merely elaborative. The following apply in all pseudocode blocks of this page. Item in pseudocode Meaning publ error Publish a Status message that indicates an error to \"Status.Error\" publ ready Publish a Status message that indicates readiness to \"Status.Ready\" topic recv epoch From \"Epoch\" topic, receive an Epoch message recv input Receive input for calculation. This does not specify the topic the input comes from. recv running From \"SimState\" topic, receive a SimState message with state \"running\" recv stop From \"SimState\" topic, receive a SimState message with state \"stopped\"","title":"How to read this page"},{"location":"core_workflow-sim/#handling-simulation-state-and-epochs","text":"recv running publ ready first_epoch = true loop wait for one of recv stop quit recv epoch // Include this if block only when implementing an initialization workflow if first_epoch first_epoch = false // Reach this block only once // Run initialization workflow run_initialization_workflow() // Run calculation workflow run_calculation_workflow() The workflow start with the reception of the state message \"running\". Then, the component announces it is ready to start by publishing \"ready\". Once all components have announced they are ready, the platform starts the actual epochs of simulation. In each epoch, the component first awaits an epoch message. However, if the platform instructs the component to stop during this wait, the component will quit. In epoch 1, the component MAY start with an initialization workflow. This means that the component communicates some parameters with other components. Regardless if an initialization workflow took place or not, the component continues to the calculation workflow. Next, the component awaits another epoch to begin.","title":"Handling simulation state and epochs"},{"location":"core_workflow-sim/#initialization-workflow","text":"Initialization workflow is an OPTIONAL step in epoch 1. In this workflow, the component communicates some information with other components before starting the calculation workflow. The component developer decides the following about the initialization workflow depending on the needs: What information is communicated How many components are involved Which messages are published Which components receive the published messages Whether each component should only receive, only publish or both receive and publish messages If the component implements an initialization workflow, this: MUST occur in epoch 1 MUST occur exactly once in each simulation run MUST occur as the first task the component accomplishes in the epoch","title":"Initialization workflow"},{"location":"core_workflow-sim/#topic-names","text":"Any topic name involved in the initialization workflow MUST start with \"Init.\". To prevent confusion in the processing of messages, a topic name involved in the calculation workflow of any component MUST NOT be involved in the initialization workflow of any component.","title":"Topic names"},{"location":"core_workflow-sim/#publish","text":"In this example, the component publishes a message in the initialization workflow. This is appropriate if the component has some information the other components need. function run_initialization_workflow() publish init_info to topic \"Init.Xyz\"","title":"Publish"},{"location":"core_workflow-sim/#receive","text":"In this example, the component receives a message in the initialization workflow. This is appropriate if the component needs some information from another component. function run_initialization_workflow() recv init_info from topic \"Init.Xyz\"","title":"Receive"},{"location":"core_workflow-sim/#calculation-workflow","text":"This section describes the rules of interaction for components within one epoch. Although the word \"calculation\" appears in the title, the component does not necessarily calculate anything. If appropriate, the component may as well supply predefined values from a time series, for instance. The calculation workflow takes place after each reception of an epoch message. That is, this excludes the reception of the epoch message!","title":"Calculation workflow"},{"location":"core_workflow-sim/#required-items","text":"function run_calculation_workflow() // 1. Calculate whatever you want. Communicate with other components as needed. // ... // 2. Report readiness publ ready When a component has finished its operation in the epoch, it MUST send a ready message. This is the sole requirement set by the platform. A particular simulation scenario CAN set further requirements to enable the components to interact, but these are beyond the core functionality of the platform.","title":"REQUIRED items"},{"location":"core_workflow-sim/#send-in-every-epoch","text":"A component MAY publish results (i.e., output data) as the developers consider appropriate, but there is a rule called \"Send in Every Epoch\" (SIEE). This means that the component SHOULD be predictable in its publishing behaviour. For example, let component C have the capability to publish a result of type R. If C publishes an R in any epoch, it SHOULD publish an R in all epochs during the simulation run. The motivation is that the other components may not know when to expect R and when not. Therefore, it is most straightforward to always publish an R. Depending on the simulation scenario, the data enclosed in R can remain unchanged between certain epochs. For instance, if the resolution of a timeseries is 60 minutes and epoch length 15 minutes, a change will occur only in every fourth epoch. To follow the SIEE rule, C would re-send the same result data again when no changes have occurred. To help other components in saving resources and possibly avoid redundant calculation, C SHOULD assign the value of the field \"LastUpdatedInEpoch\" to indicate when the most recent change has occurred (see AbstractResult ). Still, C MUST update the other metadata as specified in page AbstractResult .","title":"Send in Every Epoch"},{"location":"core_workflow-sim/#without-input-data","text":"This is an OPTIONAL workflow. It is applicable when no input data is needed for calculation. function run_calculation_workflow() calc result publ result publ ready The component calculates a result and publishes this. What is calculated and how and to which topic it is published depends on the component. Finally, the component reports readiness.","title":"Without input data"},{"location":"core_workflow-sim/#with-input-data","text":"This is an OPTIONAL workflow. It is applicable when input data is necessary for calculation. function run_calculation_workflow() wait for one of recv stop quit recv input calc result publ result publ ready Before calculation, the component waits for input data. If it the platform instruct the component to stop while waiting, the execution will end. After receiving the data, to component calculates and publishes a result. What this result is and to which topic it is published depends on the component.","title":"With input data"},{"location":"core_workflow-sim/#iterative-calculation-during-epoch","text":"","title":"Iterative calculation during epoch"},{"location":"core_workflow-sim/#basic-rules","text":"When components run an iterative algorithm during an epoch, the related functionality must be designed carefully. Iteration MUST NOT be infinite, because this would cause the simulation to get stuck. Therefore, iteration MUST be designed in one of the following ways: (a) There is a guarantee that the algorithm always converges eventually (b) If convergence cannot be guaranteed, the component MUST use another mechanism to end iteration when convergence does not occur Alternative (b) MAY require that the iterating component still publishes a reasonable result. This result MAY be: (h) A default value (i) A value calculated with a simpler algorithm (j) Anything else considered appropriate The way to guarantee a reasonable result is case-specific and therefore out of scope of the core platform. This means that the component developers MUST recognize this need on their own and design an appropriate mechanism.","title":"Basic rules"},{"location":"core_workflow-sim/#multi-component-iteration","text":"","title":"Multi-component iteration"},{"location":"core_workflow-sim/#multi-component-schemes","text":"Iteration MAY include multiple components. This means that one or more components form one or more groups where the components both produce input data to one another and consume the result data of one another. When multi-component iteration occurs, the component developers MUST take care that the iteration ends eventually. To ensure this, the component developers MUST assign each iterating component a role of either active or passive iterator: Active iterators . Each iteration group MUST include at least one active iterator component that has the ability to decide when to end iteration. Passive iterators . In a group of iterators, all components that are not active iterators are passive. These do not actively decide when to end iteration but know that they are involved in iteration. Passive iterators MUST understand the decision of an active iterator to end. The following figure illustrates a few of the potential iteration schemes. In the figure, each arrow represents how each component supplies results that are the input data of another component. The schemes include: (A) A cycle of two components, one active and one passive (B) A cycle of three components, one active and two passive (C) A cycle of three components, two active and one passive If any active iterator decides to end iteration, the result messages will deliver this information to all (D) Two iteration cycles both of which have X as the active iterator; these cycles may operate independently if wanted Still, the scheme MAY be even more complex, that is, contain more components and more cycles.","title":"Multi-component schemes"},{"location":"core_workflow-sim/#messaging-in-iteration","text":"In a multi-component iteration scheme, all iterating components MUST communicate the status of iteration in each result message. The component MUST indicate this in two ways: (1) Using the field \"IterationStatus\" (see AbstractMessage ) and (2) Using the suffix \".Iter\" in topic name when the result is intermediate and omitting this suffix when the result is final Please see the naming conventions in page Conventions of naming Together, conditions (1) and (2) ensure a uniform way to communicate which of the messages represent intermediate results and which are final. This has at least the following uses: During a simulation, enable a component to receive only final results when it does not participate in iteration After simulation, enable the separation of intermediate and final results in the retrieval of logged data The following tables tells how active and passive iterators decide whether to continue iteration. An active iterator continues iteration as long as it wants and no other iterator has declared its output as \"final\". In contrast, a passive iterator never decides when to end but instead re-uses the iteration status it has received in input. Active iterator: Does the iterator want to iterate still? IterationStatus received in input data IterationStatus to assign to result message Yes Intermediate Intermediate (iteration continues) Yes Final Final (iteration ends) No Intermediate Final (iteration ends) No Final Final (iteration ends) Passive iterator: IterationStatus received in input data IterationStatus to assign to result message Intermediate Intermediate (iteration continues) Final Final (iteration ends)","title":"Messaging in iteration"},{"location":"core_workflow-sim/#active-iterator-workflow","text":"The following code shows the basic workflow that an active iterator MAY implement for epochs. This assumes that the iterator receives exactly one result message as the input. topic = \"TopicX\" // Just an example loop // Loop to enable iteration wait for one of recv stop quit input = recv input iter_status = decide my iter status topic_temp = topic // Iter status is final if this iterator wants it or // if the input data is final if input.iter_status is final iter_status = final if iter_status is not final topic_temp = topic_temp + \".Iter\" result = calc result result.iter_status = iter_status publ result to topic_temp if iter_status is final publ ready break loop","title":"Active iterator workflow"},{"location":"core_workflow-sim/#passive-iterator-workflow","text":"The following code shows the basic workflow that a passive iterator MAY implement for epochs. This assumes that the iterator receives exactly one result message as the input. topic = \"TopicY\" // Just an example loop // Loop to enable iteration wait for one of recv stop quit input = recv input topic_temp = topic if input.iter_status is not final topic_temp = topic_temp + \".Iter\" calc result result.iter_status = input.iter_status publ result to topic_temp if input.iter_status is final publ ready break loop","title":"Passive iterator workflow"},{"location":"core_workflow-sim/#error-handling","text":"Error is a condition that the component cannot recover from. This happens when, e.g., the component receives a message it should use in calculation but the message is malformed or when there is a bug in the component that prevents further execution. Each component SHOULD be designed to detect errors. Fortunately, modern software languages have mechanisms, such as exceptions, that enable straightforward error handling. Regardless of the mechanism, the component SHOULD be ready to encounter an error anywhere in the code. Such error handling facilitates the tracking of bugs, which inevitably occur in software. Carefully implemented error handling reduces the time required for development. Not all errors can be communicated. For example, the network can be out of reach or the component can run out of memory. However, it is common that communication is still possible regardless of an error. In case an error occurs in a component, the platform has been designed to work as follows: The component reports the error The platform signals all components to stop and will publish no more epoch messages I.e., all components MUST quit If another component is busy on calculation when the stop message arrives, it MAY continue to produce a result and publish this before quitting The following explains how a component SHOULD behave when it has encountered an error. The component immediately publishes an error message (see section how to read). Now, the component waits for the platform to stop the simulation. However, if the component receives another message instead (likely the result of another component or an epoch message), it will re-publish the error message. loop publ error wait for one of recv stop quit recv epoch recv input // From here, the execution will jump to start of loop","title":"Error handling"},{"location":"core_workflow-sim/#warnings","text":"A warning means that something is wrong in the logic of a process, but this can still produce something meaningful as the result. Possible causes for warnings include, for instance: Invalid or unrealistic input data Failure to converge the calculation Warnings are informative but not fatal. Still, the presence of a warning in a message MAY cause a fatal condition in another process. When a warning occurs, the process MAY, depending on the situation: Supply default values as the result Execute a secondary calculation logic to have some result Execute its primary calculation logic, although the result can be unreliable","title":"Warnings"},{"location":"core_workflow-sim/#how-to-indicate-warning","text":"When a component thinks a warning has occurred, it SHOULD indicate this in the result message. Please see AbstractResult .","title":"How to indicate warning"},{"location":"core_workflow-sim/#logging","text":"Each component SHOULD have an internal log to help in development and debugging. The reason is that it can be difficult to include all relevant information in the messages that indicate errors or warnings. The log SHOULD contain at least: Error information (such as stack trace if the platform generates exceptions) Warning information The log MAY contain: Entries about the execution of the component, such a steps of the internal workflow Any other information considered relevant","title":"Logging"},{"location":"core_workflow-start-end/","text":"Workflow of start and end This page explains the workflow of starting and stopping a simulation run from the viewpoint of a simulation component. Overview A simulation component can be either platform managed or externally managed, which determines the workflow of starting and ending. In a simulation run, there are always at least platform-managed components, because the platform core executes in Docker and is therefore platform managed. As new components are developed, the developers decide whether to manage in the platform or externally. Platform-managed components The workflow of a platform-managed component is as follows (see also the following figure): The user runs the command to start the simulation platform. The simulation platform starts. The simulation platform starts all platform-managed components and ships any parameters to these. Each platform-managed component starts as a Docker container. In each platform-managed component: a. The component runs the simulation workflow (see Workflow of component in simulation ). b. Once the simulation workflow has finished, the component ends execution (i.e., the program exits). This will end the execution of the Docker container. Externally managed components The workflow of an externally managed component is as follows (see also the following figure): The user ensures all externally managed components are running. The user runs the command to start the simulation platform. The simulation platform starts and publishes a Start message. Exchange of publishing: management exchange Topic of publishing: \"Start\" In each externally managed component: a. The component receives the Start message b. The component runs the simulation workflow (see Workflow of component in simulation ). Once the simulation has ended, the user takes care that the externally managed components shut down if appropriate.","title":"Workflow of start and end"},{"location":"core_workflow-start-end/#workflow-of-start-and-end","text":"This page explains the workflow of starting and stopping a simulation run from the viewpoint of a simulation component.","title":"Workflow of start and end"},{"location":"core_workflow-start-end/#overview","text":"A simulation component can be either platform managed or externally managed, which determines the workflow of starting and ending. In a simulation run, there are always at least platform-managed components, because the platform core executes in Docker and is therefore platform managed. As new components are developed, the developers decide whether to manage in the platform or externally.","title":"Overview"},{"location":"core_workflow-start-end/#platform-managed-components","text":"The workflow of a platform-managed component is as follows (see also the following figure): The user runs the command to start the simulation platform. The simulation platform starts. The simulation platform starts all platform-managed components and ships any parameters to these. Each platform-managed component starts as a Docker container. In each platform-managed component: a. The component runs the simulation workflow (see Workflow of component in simulation ). b. Once the simulation workflow has finished, the component ends execution (i.e., the program exits). This will end the execution of the Docker container.","title":"Platform-managed components"},{"location":"core_workflow-start-end/#externally-managed-components","text":"The workflow of an externally managed component is as follows (see also the following figure): The user ensures all externally managed components are running. The user runs the command to start the simulation platform. The simulation platform starts and publishes a Start message. Exchange of publishing: management exchange Topic of publishing: \"Start\" In each externally managed component: a. The component receives the Start message b. The component runs the simulation workflow (see Workflow of component in simulation ). Once the simulation has ended, the user takes care that the externally managed components shut down if appropriate.","title":"Externally managed components"},{"location":"energy_conventions/","text":"Energy-domain-specific conventions","title":"Energy-domain-specific conventions"},{"location":"energy_conventions/#energy-domain-specific-conventions","text":"","title":"Energy-domain-specific conventions"},{"location":"energy_grid-dss/","text":"Grid (DSS) TODO","title":"Grid (DSS)"},{"location":"energy_grid-dss/#grid-dss","text":"TODO","title":"Grid (DSS)"},{"location":"energy_msg-networkstate-current/","text":"NetworkState.Current JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"MagnitudeSendingEnd\" : { \"Value\": 0.1, \"UnitOfMeasure\": \"A\" }, \"MagnitudeReceivingEnd\" : { \"Value\": 0.2, \"UnitOfMeasure\": \"A\" }, \"AngleSendingEnd\" : { \"Value\": 10.0, \"UnitOfMeasure\": \"deg\" }, \"AngleReceivingEnd\" : { \"Value\": 20.0, \"UnitOfMeasure\": \"deg\" }, \"DeviceId\" : \"xyz-3\", \"Phase\" : 3 } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" MagnitudeSendingEnd Quantity block 1 (REQUIRED) Always in \"A\". Sign is towards the branch. Sending end. MagnitudeReceivingEnd Quantity block 1 (REQUIRED) Always in \"A\". Sign is towards the branch. Receiving end. AngleSendingEnd Quantity block 1 (REQUIRED) Always in degrees (\"deg\" as specified in UCUM); sending end AngleReceivingEnd Quantity block 1 (REQUIRED) Always in degrees (\"deg\" as specified in UCUM); receiving end DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches Phase Integer 1 (REQUIRED) Allowed values 1,2 and 3","title":"NetworkState.Current"},{"location":"energy_msg-networkstate-current/#networkstatecurrent","text":"","title":"NetworkState.Current"},{"location":"energy_msg-networkstate-current/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"MagnitudeSendingEnd\" : { \"Value\": 0.1, \"UnitOfMeasure\": \"A\" }, \"MagnitudeReceivingEnd\" : { \"Value\": 0.2, \"UnitOfMeasure\": \"A\" }, \"AngleSendingEnd\" : { \"Value\": 10.0, \"UnitOfMeasure\": \"deg\" }, \"AngleReceivingEnd\" : { \"Value\": 20.0, \"UnitOfMeasure\": \"deg\" }, \"DeviceId\" : \"xyz-3\", \"Phase\" : 3 }","title":"JSON structure"},{"location":"energy_msg-networkstate-current/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" MagnitudeSendingEnd Quantity block 1 (REQUIRED) Always in \"A\". Sign is towards the branch. Sending end. MagnitudeReceivingEnd Quantity block 1 (REQUIRED) Always in \"A\". Sign is towards the branch. Receiving end. AngleSendingEnd Quantity block 1 (REQUIRED) Always in degrees (\"deg\" as specified in UCUM); sending end AngleReceivingEnd Quantity block 1 (REQUIRED) Always in degrees (\"deg\" as specified in UCUM); receiving end DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches Phase Integer 1 (REQUIRED) Allowed values 1,2 and 3","title":"Fields and multiplicity"},{"location":"energy_msg-networkstate-loss/","text":"NetworkState.Loss JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) ... \"DeviceId\" : \"xyz-3\" } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" RealPowerShunt Quantity block 1 (REQUIRED) Voltage-dependent losses (e.g. transformer core effect losses) RealPowerSeries Quantity block 1 (REQUIRED) Current dependent losses (e.g. line losses) ReactivePowerShunt Quantity block 0..1 (OPTIONAL) Voltage-dependent losses (e.g. transformer magnetization current) ReactivePowerSeries Quantity block 0..1 (OPTIONAL) Current dependent losses (e.g. transformer stray inductance) DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches","title":"NetworkState.Loss"},{"location":"energy_msg-networkstate-loss/#networkstateloss","text":"","title":"NetworkState.Loss"},{"location":"energy_msg-networkstate-loss/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) ... \"DeviceId\" : \"xyz-3\" }","title":"JSON structure"},{"location":"energy_msg-networkstate-loss/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" RealPowerShunt Quantity block 1 (REQUIRED) Voltage-dependent losses (e.g. transformer core effect losses) RealPowerSeries Quantity block 1 (REQUIRED) Current dependent losses (e.g. line losses) ReactivePowerShunt Quantity block 0..1 (OPTIONAL) Voltage-dependent losses (e.g. transformer magnetization current) ReactivePowerSeries Quantity block 0..1 (OPTIONAL) Current dependent losses (e.g. transformer stray inductance) DeviceId String 1 (REQUIRED) Must correspond to an entry in network model branches","title":"Fields and multiplicity"},{"location":"energy_msg-networkstate-voltage/","text":"NetworkState.Voltage JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) ... \"Magnitude\" : { \"Value\" : 227.6, \"UnitOfMeasure\" : \"kV\" }, \"Angle\" : { \"Value\" : 119.5, \"UnitOfMeasure\" : \"deg\" }, \"Bus\" : \"loadbus\", \"Node\" : 2 } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Magnitude Quantity block 1 (REQUIRED) Always in \"kV\" Angle Quantity block 1 (REQUIRED) Always in degrees (\"deg\") Bus String 1 (REQUIRED) Node Integer 1 (REQUIRED) Allowed values 1, 2 and 3","title":"NetworkState.Voltage"},{"location":"energy_msg-networkstate-voltage/#networkstatevoltage","text":"","title":"NetworkState.Voltage"},{"location":"energy_msg-networkstate-voltage/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) ... \"Magnitude\" : { \"Value\" : 227.6, \"UnitOfMeasure\" : \"kV\" }, \"Angle\" : { \"Value\" : 119.5, \"UnitOfMeasure\" : \"deg\" }, \"Bus\" : \"loadbus\", \"Node\" : 2 }","title":"JSON structure"},{"location":"energy_msg-networkstate-voltage/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Magnitude Quantity block 1 (REQUIRED) Always in \"kV\" Angle Quantity block 1 (REQUIRED) Always in degrees (\"deg\") Bus String 1 (REQUIRED) Node Integer 1 (REQUIRED) Allowed values 1, 2 and 3","title":"Fields and multiplicity"},{"location":"energy_msg-priceforecaststate/","text":"PriceForecastState JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"MarketId\": \"assign-market-here\", \"ResourceId\": \"assign-resource-here\", \"Prices\": { \"TimeIndex\" : [ \"2020-02-17T10:00:00Z\", \"2020-02-17T11:00:00Z\", \"2020-02-17T12:00:00Z\" ], \"Series\" : { \"Price\" : { \"UnitOfMeasure\" : \"{EUR}/(kW.h)\", \"Values\" : [ 0.041, 0.042, 0.043 ] } } } } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" MarketId String 1 (REQUIRED) Market identifier ResourceId String 0..1 (OPTIONAL) The resource related to the price. If there is no resource specified, the message MUST contain market prices. PricingType ? 0..1 (OPTIONAL) ? Prices Time series block 1 (REQUIRED) See (1) below (1) Series included in the block: REQUIRED: \"Price\" Unit of measure: \"{EUR}/(kW.h)\" (or \"{EUR}/(MW.h)\"?) Currencies are not supported in UCUM, therefore \"EUR\" is an annotation in curly brackets OPTIONAL: variance or similar (TBD!)","title":"PriceForecastState"},{"location":"energy_msg-priceforecaststate/#priceforecaststate","text":"","title":"PriceForecastState"},{"location":"energy_msg-priceforecaststate/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"MarketId\": \"assign-market-here\", \"ResourceId\": \"assign-resource-here\", \"Prices\": { \"TimeIndex\" : [ \"2020-02-17T10:00:00Z\", \"2020-02-17T11:00:00Z\", \"2020-02-17T12:00:00Z\" ], \"Series\" : { \"Price\" : { \"UnitOfMeasure\" : \"{EUR}/(kW.h)\", \"Values\" : [ 0.041, 0.042, 0.043 ] } } } }","title":"JSON structure"},{"location":"energy_msg-priceforecaststate/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" MarketId String 1 (REQUIRED) Market identifier ResourceId String 0..1 (OPTIONAL) The resource related to the price. If there is no resource specified, the message MUST contain market prices. PricingType ? 0..1 (OPTIONAL) ? Prices Time series block 1 (REQUIRED) See (1) below (1) Series included in the block: REQUIRED: \"Price\" Unit of measure: \"{EUR}/(kW.h)\" (or \"{EUR}/(MW.h)\"?) Currencies are not supported in UCUM, therefore \"EUR\" is an annotation in curly brackets OPTIONAL: variance or similar (TBD!)","title":"Fields and multiplicity"},{"location":"energy_msg-resourcestate/","text":"ResourceState JSON structure { (Fields of AbstractMessage and AbstractResult must appear too!) \"Bus\" : \"loadbus1\", \"RealPower\" : { \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"ReactivePower\" : { \"Value\": 0.0, \"UnitOfMeasure\": \"kV.A{r}\" }, \"Node\" : 2, // Optional \"StateOfCharge\" : { \"Value\": 68.1, \"UnitOfMeasure\": \"%\" } // Optional } Fields and multiplicity Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Bus String 1 (REQUIRED) Name of bus to which the resource is connected. RealPower Quantity block 1 (REQUIRED) 'Towards the grid' is positive. Always in \"kW\". ReactivePower Quantity block 1 (REQUIRED) Reactive power. Always in \"kV.A{r}\" Node Integer 0..1 (OPTIONAL) Node that 1-phase resource is connected to. Possible values 1, 2 and 3. If this is not specified then it is assumed that the resource is 3-phase resource. StateOfCharge Quantity block 0..1 (OPTIONAL) Present amount of energy stored, % of rated kWh. Unit of measure: \"%\".","title":"ResourceState"},{"location":"energy_msg-resourcestate/#resourcestate","text":"","title":"ResourceState"},{"location":"energy_msg-resourcestate/#json-structure","text":"{ (Fields of AbstractMessage and AbstractResult must appear too!) \"Bus\" : \"loadbus1\", \"RealPower\" : { \"Value\": 100.0, \"UnitOfMeasure\": \"kW\" }, \"ReactivePower\" : { \"Value\": 0.0, \"UnitOfMeasure\": \"kV.A{r}\" }, \"Node\" : 2, // Optional \"StateOfCharge\" : { \"Value\": 68.1, \"UnitOfMeasure\": \"%\" } // Optional }","title":"JSON structure"},{"location":"energy_msg-resourcestate/#fields-and-multiplicity","text":"Field Type Multiplicity Explanation (All fields from AbstractResult and AbstractMessage ) Fields from the \"abstract base class\" Bus String 1 (REQUIRED) Name of bus to which the resource is connected. RealPower Quantity block 1 (REQUIRED) 'Towards the grid' is positive. Always in \"kW\". ReactivePower Quantity block 1 (REQUIRED) Reactive power. Always in \"kV.A{r}\" Node Integer 0..1 (OPTIONAL) Node that 1-phase resource is connected to. Possible values 1, 2 and 3. If this is not specified then it is assumed that the resource is 3-phase resource. StateOfCharge Quantity block 0..1 (OPTIONAL) Present amount of energy stored, % of rated kWh. Unit of measure: \"%\".","title":"Fields and multiplicity"},{"location":"energy_msgtype/","text":"Message type names (energy) Message Type name (case sensitive) ControlState.PowerSetpoint ControlState DMSNetworkStatus (same as message name) FlexibilityNeed (same as message name) Init.CIS.CustomerInfo (same as message name) Init.NIS.NetworkBusInfo (same as message name) Init.NIS.NetworkComponentInfo (same as message name) LFMMarketResult (same as message name) LFMOffering ? NetworkState.Current (same as message name) NetworkState.Loss (same as message name) NetworkState.Voltage (same as message name) Offer (same as message name) PriceForecastState (same as message name) ResourceForecastState.Dispatch (same as message name) ResourceForecastState.Power (same as message name) ResourceState (same as message name) Request (same as message name) SelectedOffer (same as message name)","title":"Message type names (energy)"},{"location":"energy_msgtype/#message-type-names-energy","text":"Message Type name (case sensitive) ControlState.PowerSetpoint ControlState DMSNetworkStatus (same as message name) FlexibilityNeed (same as message name) Init.CIS.CustomerInfo (same as message name) Init.NIS.NetworkBusInfo (same as message name) Init.NIS.NetworkComponentInfo (same as message name) LFMMarketResult (same as message name) LFMOffering ? NetworkState.Current (same as message name) NetworkState.Loss (same as message name) NetworkState.Voltage (same as message name) Offer (same as message name) PriceForecastState (same as message name) ResourceForecastState.Dispatch (same as message name) ResourceForecastState.Power (same as message name) ResourceState (same as message name) Request (same as message name) SelectedOffer (same as message name)","title":"Message type names (energy)"},{"location":"energy_resources/","text":"Resources TODO: add page content","title":"Resources"},{"location":"energy_resources/#resources","text":"TODO: add page content","title":"Resources"},{"location":"energy_software-pkg/","text":"Software packages To reduce the amount of redundant development work, there are re-usable software packages. Domain Messages This package implements classes for processing messages that multiple components must use in communication. These messages include at least ResourceState and PriceForecastState. The package and its detailed documentation are available at TODO","title":"Software packages"},{"location":"energy_software-pkg/#software-packages","text":"To reduce the amount of redundant development work, there are re-usable software packages.","title":"Software packages"},{"location":"energy_software-pkg/#domain-messages","text":"This package implements classes for processing messages that multiple components must use in communication. These messages include at least ResourceState and PriceForecastState. The package and its detailed documentation are available at TODO","title":"Domain Messages"},{"location":"energy_topic-priceforecaststate/","text":"PriceForecastState.(MarketId).(ResourceId) This topic uses subtopics to enable finer-grained message routing. The naming is as follows: PriceForecastState.(MarketId).(ResourceId) For a particular message, the ResourceId part MUST match the identifier of the related resource! This can be, e.g.: PriceForecastState.MyMarket.(ResourceId)","title":"PriceForecastState.(MarketId).(ResourceId)"},{"location":"energy_topic-priceforecaststate/#priceforecaststatemarketidresourceid","text":"This topic uses subtopics to enable finer-grained message routing. The naming is as follows: PriceForecastState.(MarketId).(ResourceId) For a particular message, the ResourceId part MUST match the identifier of the related resource! This can be, e.g.: PriceForecastState.MyMarket.(ResourceId)","title":"PriceForecastState.(MarketId).(ResourceId)"},{"location":"energy_topic-resourceforecaststate/","text":"ResourceForecastState.(ResourceCategory).(ResourceId) This topic uses subtopics to enable finer-grained message routing. The naming is as follows: ResourceForecastState.(ResourceCategory).(ResourceId) The supported resource categories are specified in the page of the component Resources . For example: ResourceForecastState.Generator.Generator1 Please note that subtopics do not prevent any component from receiving messages from all subtopics, as there can be wildcard subscriptions.","title":"ResourceForecastState.(ResourceCategory).(ResourceId)"},{"location":"energy_topic-resourceforecaststate/#resourceforecaststateresourcecategoryresourceid","text":"This topic uses subtopics to enable finer-grained message routing. The naming is as follows: ResourceForecastState.(ResourceCategory).(ResourceId) The supported resource categories are specified in the page of the component Resources . For example: ResourceForecastState.Generator.Generator1 Please note that subtopics do not prevent any component from receiving messages from all subtopics, as there can be wildcard subscriptions.","title":"ResourceForecastState.(ResourceCategory).(ResourceId)"},{"location":"energy_topic-resourcestate/","text":"ResourceState.(ResourceCategory).(ResourceId) This topic uses subtopics to enable finer-grained message routing. The naming is as follows: ResourceState.(ResourceCategory).(ResourceId) The supported resource categories are specified in the page of the components Resources . For a particular message, the ResourceId part MUST match SourceProcessId in the message! Example: ResourceState.Generator.Generator1 Please note that subtopics do not prevent any component from receiving messages from all subtopics, as there can be wildcard subscriptions.","title":"ResourceState.(ResourceCategory).(ResourceId)"},{"location":"energy_topic-resourcestate/#resourcestateresourcecategoryresourceid","text":"This topic uses subtopics to enable finer-grained message routing. The naming is as follows: ResourceState.(ResourceCategory).(ResourceId) The supported resource categories are specified in the page of the components Resources . For a particular message, the ResourceId part MUST match SourceProcessId in the message! Example: ResourceState.Generator.Generator1 Please note that subtopics do not prevent any component from receiving messages from all subtopics, as there can be wildcard subscriptions.","title":"ResourceState.(ResourceCategory).(ResourceId)"},{"location":"energy_topics/","text":"Topics (energy) The following table shows which message type occurs in each topic. If a topic has subtopics, there is a dedicated page for it. The table below is normative. This means that if any other page has a conflicting topic name, this table has the precedence. In many cases, each message structure only occurs in one topic, but a message structure can be reusable between topics as well. For instance, several topics might deliver forecasts using an identical structure. However, in one topic, you likely expect only one message type. Topic Message type Purpose; see (1) Publisher(s) Subscriber(s) TODO: add table content (1) Purposes: Initialization: initializing before the actual simulation cycles have begun (once for each simulation run) Results: communication of result data during simulation (multiple times during a simulation run)","title":"Topics (energy)"},{"location":"energy_topics/#topics-energy","text":"The following table shows which message type occurs in each topic. If a topic has subtopics, there is a dedicated page for it. The table below is normative. This means that if any other page has a conflicting topic name, this table has the precedence. In many cases, each message structure only occurs in one topic, but a message structure can be reusable between topics as well. For instance, several topics might deliver forecasts using an identical structure. However, in one topic, you likely expect only one message type. Topic Message type Purpose; see (1) Publisher(s) Subscriber(s) TODO: add table content (1) Purposes: Initialization: initializing before the actual simulation cycles have begun (once for each simulation run) Results: communication of result data during simulation (multiple times during a simulation run)","title":"Topics (energy)"}]}